# 《MySQL技术内幕：InnoDB存储引擎》

## 第五章 索引与算法

### 前言

索引是应用程序设计和开发的一个重要方面。如果知道数据的使用，从一开始就应该在需要处添加索引。

### InnoDB存储引擎索引概述

InnoDB存储引擎支持以下几种常见的索引：

* B+树索引
* 哈希索引
* 全文索引

前面已经提到，InnoDB存储引擎的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

B+树索引就是传统意义上的索引，这是目前关系型数据库中查找最为常用和最为有效的索引，B+树的构造类似于一棵二叉树，根据键值来快速找到数据。B+树的B不是二叉(binary)，而是balance平衡，因为B+树最早是从平衡二叉树演化而来的，但是B+树并不是一个二叉树。

注意：B+树索引并不能找到一个给定键值的具体行，B+树索引能找到的只是被查找的数据行所在的页，然后数据库通过把页读入内存中，再在内存中进行查找，最后得到想要的数据。

### 补充（浅谈索引演进过程）

~~~wiki
对于可以提升查找效率的数据结构，首先应该想到的是哈希表，在大部分情况下可以以O(1)的时间复杂度来获取一个数据，如果有哈希碰撞，那么时间复杂度取决于如果解决哈希碰撞，即其使用的数据结构，但是在大部分情况下，哈希表还是一种非常快的查找数据结构。

哈希表作为索引的最大缺点是无法做范围查询，因为作为查找的key在哈希表里不是递增的，如果要做范围查询，那么相当于就是全表扫描，找到这个区间内所有的key进行查询，所以哈希表这个结构作为索引的底层实现只适合等值查询。

那么要想解决等值查询与范围查询都有一个不错的效率，可以想到排序数据，由于数据的有序的，对于单个值的查找，可以通过索引键进行二分查找，logN，对于范围查找也天然支持。但是数组这种结构，如果在中间插入数据，那么需要向后移动所有的数据，同时需要考虑数据扩容带来的性能损耗，对于数据的扩容，比如是要进行拷贝的，当数据量非常大的时候，效率较低

所以排序数据只适合做静态存储的需求的查找的索引实现，比如在今年年底统计出来一个全国人口的分布信息，在统计出来以后这个数据对于目前来说是一种最终结果了，不会再改变。

那么同样用到二分查找思想，并且在删除方面效率较高，并且不需要动态扩容的数据结构，又可以想到二叉查找树，对于二叉查找树，它的时间复杂度也是logN，跟有序数组持平，但是存在一个严重的问题，如果数据情况比较极端，二叉查找树可能会退化为链表，查找又变成了On，为此又能想到平衡二叉树，通过左旋或者右旋的方式来维持树的平衡，那么现在看起来平衡二叉树好像能完美满足需求了，但是在数据库中运用最多的却不是平衡二叉树，其原因是，索引不止在内存中，还要写到磁盘上。对于二叉树，它的节点个数与树高的对应公式是如果深度为N，最多有2的N次方-1个节点，那么假设有一百万个节点，一百万接近2的20次方，2的20次方是一百零四万，也就是说这个时候树的高度的20，一次查询可能需要访问20个机械磁盘的数据块，从机械磁盘中读取定位一个数据块需要10ms左右的时间，这个时间是移动臂根据柱面号使磁头移动到所需柱面上的时间，这一过程一般被称为寻址或者定位或查找，这部分时间是机械硬盘查找过程中所耗费的最多的一部分时间，那么如果一次查询需要访问20个数据块，那么就需要200ms，这个查询速度是不能接收的，为了让一个查询尽量少地读取磁盘，就必须让查询过程尽可能少的访问数据块，那么解决思路是把树变矮，怎么把二叉树变矮，用多叉树，假如用一个1000叉树，树高为3，那么可以存储1000的三次方，就是10亿个数据，树高为3，意味着由于根的数据块总是在内存中，那么在十亿个数据中查找一个数据，最多只需要访问两次磁盘，其实树的第二层一般也有很大的可能在内存中，那么访问磁盘的数量就更少了。综上所述，N叉树由于在读写性能上的优势，以及适配磁盘的访问方式，最终被广泛应用到数据库的索引实现中。
最终innodb选择了B+树作为索引的底层实现，树的高度被降的很低，查询是类二叉查找，时间复杂度接近logN，B+树可以很好的配合磁盘的读写特性，有效减少单次查询的磁盘访问次数
~~~

### 二叉查找树与平衡二叉树

B+树是由二叉查找树，平衡二叉树，B树演化而来的。在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。因此通过中序遍历二叉查找树就可以得到键值的排序输出。二叉查找树的平均查找次数小于顺序查找的次数。

二叉查找树可以任意的构造，那么在某些情况下，二叉查找树的形状可能会是一个链表结构，那么它的查找速率又与顺序查找相当了，所以二叉查找树的查找效率可能会变得很低。

为了最大性能的构造一棵二叉查找树，需要这棵二叉查找树是平衡的，从而引出了新的定义--平衡二叉树，也就是AVL树

平衡二叉树的定义如下，首先符合二叉查找树的定义，也就是左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，其次必须满足任何节点的两个子树的高度差的绝对值最大不能超过1。平衡二叉树的查找性能是比较高的，但不是最高的，只是接近最高性能，最好的性能是建立一棵最优二叉树，但是最优二叉树的建立和维护需要大量的操作，因此，用户一般只需要建立一棵平衡二叉树就可以了。

平衡二叉树的查找速度的确很快，但是维护它的平衡同样需要付出一定的代价。每当有元素发生更新或添加或删除操作时，AVL树就需要通过左旋或右旋的方式来维持平衡，不过平衡二叉树多用于内存结构对象中，因此维护的开销也不是特别大。

### B+树

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中所有节点都是按照键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。

### B+树的插入操作

B+树的插入必须保证插入后叶子结点中的记录依然排序，同时还需要考虑插入到B+树的三种情况：

* leaf page未满，index page未满，这时是直接将记录插入到叶子节点
* leaf page满，index page未满，这时候首先拆分leaf page，然后将中间的节点插入到index page中，小于中间节点的记录放在左边，大于或等于中间节点的记录放在右边
* leaf page满，index page满，查分leaf page，后同上，拆分index page，后同上，中间节点放入上一层的index page中

可以看到，不管怎么变化，B+树总会保持平衡，但是为了保持平衡对新插入的键值可能需要做大量的拆分页的操作，因为B+树结构主要用于磁盘，那么拆分页的操作意味着磁盘的操作，所以应该尽可能的减少拆分页的操作，因此，B+树同样提供了类似AVL树的旋转功能。

旋转发生在leaf page已满，但是其左右兄弟节点没有满的情况下，这时B+树不急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上，在通常情况下，左兄弟会首先被检查用来做旋转操作。采用旋转操作可以减少B+树的拆分页操作次数，同时树的高度也不会变化

### B+树的删除操作

B+树使用填充因子来控制树的删除变化，B+树的删除操作同样需要保证删除后叶子节点的记录依然排序

B+树删除操作的三种情况：

* 叶子节点不小于填充因子，中间节点不小于填充因子，这时直接将记录从叶子节点删除，如果该节点还是index page的节点，用该节点的右节点来替代
* 叶子节点小于填充因子，中间节点不小于填充因子，这时要合并叶子节点和它的兄弟节点，同时更新index page
* 叶子节点小于填充因子，中间节点小于填充因子，这时首先合并叶子节点和它的兄弟节点，更新index page，最后合并index page和它的兄弟节点

### B+树索引

B+树索引的本质就是B+树在数据库中的实现，但是B+树索引在数据库中有一个特点是高扇出性，因此在数据库中B+树的高度一般是2-4层，这也就是说查询某一键值的记录最多只需要2-4次IO。

数据库中的B+树索引分为聚集索引和辅助索引，辅助索引也叫非聚集索引。其内部都是B+树，即高度平衡的，叶子节点存放着所有数据，聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

### 聚集索引

InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放，而聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。每个数据页都通过一个双向链表来连接。

由于实际的数据页只能按照一棵B+树进行排序，所以每张表只能拥有一个聚聚索引，在多数情况下，查询优化器倾向于使用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据，此外，由于定义了数据的逻辑顺序，聚集索引能够特别快的针对范围值的查询。

在数据页上存放的是完整的每行的记录，在非数据页的索引页中，存放的是键值以及指向数据页的偏移量。

聚集索引的存储并不是物理上连续的，而是逻辑上连续的。其中有两点：一是页通过双向链表连接，页按照主键的顺序排序；二是每个页中的记录也是通过双向链表维护的，物理存储上可以同样不按照主键存储。

聚集索引的好处是它对于主键的排序查找和范围查找速度非常快。

### 补充（聚集索引与非聚集索引）

~~~wiki
根据叶子节点的内容，索引类型可以分为主键索引和非主键索引或者辅助索引，主键索引的叶子节点存储的是整行数据，在innodb存储引擎中，
主键索引也别称为聚簇索引，非主键索引的叶子结点存放的内容是主键的值，索引非主键索引也叫非聚集索引或者二级索引，主键索引从根节点开始沿着非叶子节点一路依靠主键进行类二叉查找，或者叫区间查找，最终走到叶子节点，叶子节点就是整行数据，但是对于非主键索引，
使用非主键key进行类二分查找，最终走到叶子节点以后，叶子节点存放的是当前行记录的主键，最终拿着这个主键再去主键索引树中去查找真正的行记录，这个工程称为回表。也就是说基于非主键索引的查询需要多扫描一棵索引树，所以在查询中，尽量多实用主键索引
从普通索引搜索结束以后带着叶子节点的主键去主键索引树上去搜，就叫回表
同时主键长度越小，那么普通索引的叶子节点就会越少，普通索引所占用的空间就会越少
~~~

### 补充（为什么建议使用自增主键作为索引？）

~~~wiki
innodb是索引组织表，一般情况下建议创建一个自增主键，这样非主键索引的空间占用就会非常少，但是真实场景还得根据业务逻辑来定，
~~~

### 辅助索引

辅助索引也被称为非聚集索引，叶子节点并不包含行记录的全部数据，叶子节点除了包含键值以外，每个叶子节点的索引行还包含了一个书签(bookmark)，该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不影响聚集索引中的组织，因此每张表上可以建立多个辅助索引，当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来获取一个完整的行记录。

举例来说，如果在一棵高度为3的辅助索引树中查找数据，就需要对这颗辅助索引树查找3次找到指定主键，如果聚集索引树的高度也为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行记录所在的页，因此一共需要6次IO即可访问到最终的数据页。

### B+树索引的管理

Cardinality值非常关键，优化器会根据这个值来决定是否使用这个索引，但是这个值还不是实时更新的，这就很坑，但是你可以通过analyze table命令来强制更新，但是这个强制更新操作会非常消耗时间和性能，所以最好在应用的低峰期来进行刷表

并不是在所有的查询条件中出现的字段都需要添加索引，一般认为，在访问表中很少一部分时使用B+树才有意义。

同时这个字段也应该是高选择性的，也就是说这个字段的取值范围很广，几乎没有重复。Cardinality值就是记录索引中不重复记录的数量的预估值。在实际应用中，我们应该尽量让Cardinality / table rows的值接近1，这样代表了数据重复出现的次数很好，能完美用到B+树索引。

数据库对Cardinality值的统计是通过采样的方式，默认InnoDB存储引擎对8个叶子节点进行采样，所以得到的值是一个预估值，而不是精确值，同时有可能每次得到的Cardinality值是不同的。

### B+树索引的使用

在OLTP应用中，查询操作每次只从数据库中获取一小部分数据，一般可能在十条以内，甚至一条，比如根据主键来查询用户信息，根据订单号来查询订单详情等，在这种情况下，B+树索引建立后，对该索引的使用应该只是通过该索引获取表中少部分数据，这时建立B+树索引才是有意义的。

### 联合索引

从本质上来说，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2。联合索引的好处是已经对第二个键值进行了排序处理，例如，在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以避免多一次的排序操作，因为索引本身在叶子节点就已经排序好了，比如说本例子中的buy_date字段，那么在如下sql语句：select * from bug_log where id = 3  order by buy_date desc limit 3中buy_date已经排序好了，根据联合索引取出数据，无须对buy_date再做一次排序工作。

### 覆盖索引

覆盖索引直接在非聚集索引上就找了值，不需要在通过叶子节点存储的主键进行一次主键索引树的扫描

### 覆盖索引补充

~~~wiki
覆盖索引的使用：
假设这样一种需求，我们需要根据一个字段去查找主键列的值，由于我们只需要获取主键列的值，而主键列的值被存在普通索引的叶子节点上，所以我们可以直接通过普通索引就能查找到想要的主键索引列上的值，就好像被覆盖了一样，覆盖索引可以直接省去一次主键索引树的查找
是一种常用的性能优化手段，同时使用覆盖索引，用explain分析后会看到在extra列中显示useing index信息
~~~

覆盖索引，即从辅助索引中就可以获得查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处就是辅助索引不包含整行记录的信息，因此大小远小于聚集索引，因此可以大大减少IO操作

对于InnoDB存储引擎的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为(primary key1,primary key2，key1，key2)，那么下面这个sql语句就可以通过一次辅助联合索引来完成查询

select key2 from table where key1 = xxxx；

### 补充（最左前缀原则）

~~~wiki
假设给一张表的name和age字段建立联合索引，在索引树中我们会根据索引字段的定义在索引树中向下查找，当我们需要查询名字是xx的人时，可以快速定位到那个叶子节点，由于排好了序，可以快速的从这个树节点向后遍历，取得所有名字以xx开头的人的索引字段定义的信息，比如name和age，可以看到，不只是索引列中定义，只要满足最左前缀，就可以利用索引来加速检索，这个最左前缀代表的含义可以是联合索引的最左N个字段，也可以是字符串索引的最左N个字符，有了这个基础，应该思考在建立联合索引的时候，如何安排内部索引字段的顺序，顺序安排
合理的话，可以少维护一个索引，比如已经了(a,b)，那么就可以不加单独的a索引，所以这个顺序往往是考虑采用的。

联合索引的索引下推概念：在mysql5.6以后引入的。
如果有这样一个需求，查询名字以x打头，并且年龄是10的人的信息，如果在mysql5.6以前，根据最左前缀，只能用以x开头来找到第一个满足的记录，然后开始向后判断第二个索引列，当然这样子也看起来不错，不需要全表扫描。
从mysql5.6开始，引入索引下推优化，在索引遍历过程中，可以对索引字段的数据进行判断了，直接过滤掉不满足条件的记录，减少回表次数
~~~

### 优化器选择不适用索引的情况

有时候我们使用explain去分析sql语句时，会发现优化器并没有选择索引去查找数据，而是通过全表扫描的方式，扫描聚集索引。这种情况多发生于范围查找，JOIN连接等操作。

注意，如果用户要选取的数据是整行信息，而orderID索引不能覆盖到我们要查询的信息，因此在对orderID索引查询到指定数据后，还需要一次书签访问来查找整行的数据信息，虽然orderID索引中的数据是有序的，但是再一次进行书签查找的数据是无序的，因此变为了磁盘上的离散读操作，如果要求访问的数据量很小，那么优化器还是会选择辅助索引，但是当访问的数据占整个表的很大一部分时，优化器就会使用聚集索引来查找数据。

### mutil-range-read优化

mrr优化的目的是减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问。这对于io密集型的sql查询语句带来了巨大的性能提升，mrr优化可用于range，ref，eq_ref类型的查询。

* mrr使数据的访问变得较为顺序，在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，然后按照主键排序的顺序进行书签查找

### index condition pushdown（ICP）优化

在支持icp以前，当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录，支持了icp以后，mysql数据库会在取出索引的同时，判断是否可以进行where条件的过滤，也就是将where部分的过滤操作放在了存储引擎层，在某些查询下，可以大大减少上层sql层对记录的索取，从而提高数据库的整体性能。

### 哈希算法

哈希算法是一种常见算法，时间复杂度为o(1)，设想一个问题，在一个内存为128G的服务器中，怎么从中找到一个缓存的页呢？即使内存中查询速度很快，但也不可能每次都遍历所有内存来进行查找，这时对于字典操作只需O(1)的哈希算法就排上了用场。

哈希表也叫散列，是由寻址表改进而来的。

直接寻址技术有一个很大的问题，如果域U很大，那么在计算机可用存储的限制下，要存储一张大小为U的表T有点不符合实际，并且如果实际要存储的关键字集合K相对于U来说很小，那么分配给T的大部分空间都要浪费掉。

因此哈希表出现了，在哈希方式下，该元素处于h(K)中，利用哈希函数根据K来计算出槽或者桶的位置。但是也有一个小问题，就是哈希碰撞问题，在数据库中解决的办法是链地址法。

### 全文检索

B+树索引对于索引字段的前缀是可以进行查找的，比如查找这篇博客以xxx开头的字段，但是实际应用中，更多的情况是查找这篇博客包含xxx内容的字段。

根据B+树的特性，对于这种情况，即便添加了B+树索引也是需要进行索引的扫描来得到结果的。这种需求是非常多的，比如电商网站根据用户的查询条件，在可能需要的商品的详细介绍中进行查找，这些都不是B+树能很好完成的工作。

### 倒排索引

全文索引通常使用倒排索引来实现，它与B+树索引一样，也是一种索引结构，它在辅助表中存储了单词与单词自身在一个或多个文档中的位置之间的映射。这通常使用关联数组实现。主要有两种表现形式：

* inverted file index，表现形式为{单词，单词所在的文档的ID}
* full inverted index，表现形式为{单词，（单词所在文档的ID，在具体文档中的位置）}

InnoDB存储引擎采用full inverted index方式的倒排索引来实现全文检索。

### 总结

本文介绍了索引的数据结构与基本增加与删除操作，从数据结构的角度切入数据库中常见的索引的使用，并从内部机制上讨论了使用索引的环境，注意事项和优化方法。