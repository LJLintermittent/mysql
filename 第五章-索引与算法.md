# 《MySQL技术内幕：InnoDB存储引擎》

## 第五章 索引与算法

### 前言

索引是应用程序设计和开发的一个重要方面。如果知道数据的使用，从一开始就应该在需要处添加索引。

### InnoDB存储引擎索引概述

InnoDB存储引擎支持以下几种常见的索引：

* B+树索引
* 哈希索引
* 全文索引

前面已经提到，InnoDB存储引擎的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

B+树索引就是传统意义上的索引，这是目前关系型数据库中查找最为常用和最为有效的索引，B+树的构造类似于一棵二叉树，根据键值来快速找到数据。B+树的B不是二叉(binary)，而是balance平衡，因为B+树最早是从平衡二叉树演化而来的，但是B+树并不是一个二叉树。

注意：B+树索引并不能找到一个给定键值的具体行，B+树索引能找到的只是被查找的数据行所在的页，然后数据库通过把页读入内存中，再在内存中进行查找，最后得到想要的数据。

### 二叉查找树与平衡二叉树

B+树是由二叉查找树，平衡二叉树，B树演化而来的。在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。因此通过中序遍历二叉查找树就可以得到键值的排序输出。二叉查找树的平均查找次数小于顺序查找的次数。

二叉查找树可以任意的构造，那么在某些情况下，二叉查找树的形状可能会是一个链表结构，那么它的查找速率又与顺序查找相当了，所以二叉查找树的查找效率可能会变得很低。

为了最大性能的构造一棵二叉查找树，需要这棵二叉查找树是平衡的，从而引出了新的定义--平衡二叉树，也就是AVL树

平衡二叉树的定义如下，首先符合二叉查找树的定义，也就是左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，其次必须满足任何节点的两个子树的高度差的绝对值最大不能超过1。平衡二叉树的查找性能是比较高的，但不是最高的，只是接近最高性能，最好的性能是建立一棵最优二叉树，但是最优二叉树的建立和维护需要大量的操作，因此，用户一般只需要建立一棵平衡二叉树就可以了。

平衡二叉树的查找速度的确很快，但是维护它的平衡同样需要付出一定的代价。每当有元素发生更新或添加或删除操作时，AVL树就需要通过左旋或右旋的方式来维持平衡，不过平衡二叉树多用于内存结构对象中，因此维护的开销也不是特别大。

### B+树

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中所有节点都是按照键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。

### B+树的插入操作

B+树的插入必须保证插入后叶子结点中的记录依然排序，同时还需要考虑插入到B+树的三种情况：

* leaf page未满，index page未满，这时是直接将记录插入到叶子节点
* leaf page满，index page未满，这时候首先拆分leaf page，然后将中间的节点插入到index page中，小于中间节点的记录放在左边，大于或等于中间节点的记录放在右边
* leaf page满，index page满，查分leaf page，后同上，拆分index page，后同上，中间节点放入上一层的index page中

可以看到，不管怎么变化，B+树总会保持平衡，但是为了保持平衡对新插入的键值可能需要做大量的拆分页的操作，因为B+树结构主要用于磁盘，那么拆分页的操作意味着磁盘的操作，所以应该尽可能的减少拆分页的操作，因此，B+树同样提供了类似AVL树的旋转功能。

旋转发生在leaf page已满，但是其左右兄弟节点没有满的情况下，这时B+树不急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上，在通常情况下，左兄弟会首先被检查用来做旋转操作。采用旋转操作可以减少B+树的拆分页操作次数，同时树的高度也不会变化

### B+树的删除操作

B+树使用填充因子来控制树的删除变化，B+树的删除操作同样需要保证删除后叶子节点的记录依然排序

B+树删除操作的三种情况：

* 叶子节点不小于填充因子，中间节点不小于填充因子，这时直接将记录从叶子节点删除，如果该节点还是index page的节点，用该节点的右节点来替代
* 叶子节点小于填充因子，中间节点不小于填充因子，这时要合并叶子节点和它的兄弟节点，同时更新index page
* 叶子节点小于填充因子，中间节点小于填充因子，这时首先合并叶子节点和它的兄弟节点，更新index page，最后合并index page和它的兄弟节点

### B+树索引

B+树索引的本质就是B+树在数据库中的实现，但是B+树索引在数据库中有一个特点是高扇出性，因此在数据库中B+树的高度一般是2-4层，这也就是说查询某一键值的记录最多只需要2-4次IO。

数据库中的B+树索引分为聚集索引和辅助索引，辅助索引也叫非聚集索引。其内部都是B+树，即高度平衡的，叶子节点存放着所有数据，聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

### 聚集索引

InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放，而聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。每个数据页都通过一个双向链表来连接。

由于实际的数据页只能按照一棵B+树进行排序，所以每张表只能拥有一个聚聚索引，在多数情况下，查询优化器倾向于使用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据，此外，由于定义了数据的逻辑顺序，聚集索引能够特别快的针对范围值的查询。

在数据页上存放的是完整的每行的记录，在非数据页的索引页中，存放的是键值以及指向数据页的偏移量。

聚集索引的存储并不是物理上连续的，而是逻辑上连续的。其中有两点：一是页通过双向链表连接，页按照主键的顺序排序；二是每个页中的记录也是通过双向链表维护的，物理存储上可以同样不按照主键存储。

聚集索引的好处是它对于主键的排序查找和范围查找速度非常快。

### 辅助索引

辅助索引也被称为非聚集索引，叶子节点并不包含行记录的全部数据，叶子节点除了包含键值以外，每个叶子节点的索引行还包含了一个书签(bookmark)，该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不影响聚集索引中的组织，因此每张表上可以建立多个辅助索引，当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来获取一个完整的行记录。

举例来说，如果在一棵高度为3的辅助索引树中查找数据，就需要对这颗辅助索引树查找3次找到指定主键，如果聚集索引树的高度也为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行记录所在的页，因此一共需要6次IO即可访问到最终的数据页。

### B+树索引的管理

Cardinality值非常关键，优化器会根据这个值来决定是否使用这个索引，但是这个值还不是实时更新的，这就很坑，但是你可以通过analyze table命令来强制更新，但是这个强制更新操作会非常消耗时间和性能，所以最好在应用的低峰期来进行刷表

并不是在所有的查询条件中出现的字段都需要添加索引，一般认为，在访问表中很少一部分时使用B+树才有意义。

同时这个字段也应该是高选择性的，也就是说这个字段的取值范围很广，几乎没有重复。Cardinality值就是记录索引中不重复记录的数量的预估值。在实际应用中，我们应该尽量让Cardinality / table rows的值接近1，这样代表了数据重复出现的次数很好，能完美用到B+树索引。

数据库对Cardinality值的统计是通过采样的方式，默认InnoDB存储引擎对8个叶子节点进行采样，所以得到的值是一个预估值，而不是精确值，同时有可能每次得到的Cardinality值是不同的。

### B+树索引的使用

在OLTP应用中，查询操作每次只从数据库中获取一小部分数据，一般可能在十条以内，甚至一条，比如根据主键来查询用户信息，根据订单号来查询订单详情等，在这种情况下，B+树索引建立后，对该索引的使用应该只是通过该索引获取表中少部分数据，这时建立B+树索引才是有意义的。

### 联合索引

