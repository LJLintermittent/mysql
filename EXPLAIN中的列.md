## ID列

这一列总是包含一个编号，标识select所属的行。如果在语句当中没有子查询或者联合查询，那么只会有唯一的SELECT。于是每一行在这个列都将显示一个1

MySQL将select查询分为简单查询和复杂查询，复杂查询可以分为三大类：简单子查询，在from中的子查询和union查询。

注意：MySQL5.6允许解释非select查询。

## SELECT_TYPE列

这一列显示了对应行是简单还是复杂select，（如果是复杂select，那么是三种复杂查询的哪一种）

simple值意味着查询不包括子查询或联合查询，如果查询中有任何复杂的子部分，则最外层部分标记为primary

subquery：包含在select列表中的子查询的中的select（不在from语句中的）

derived：derived用来表示包含在from子句中的子查询中的select，MySQL会递归执行并将结果放到一个临时表，MySQL内部将其称为派生表，因为该临时表是从子查询中派生出来的。

union：在union中的第二个和随后的select被标记为union。

union result：用来从union的匿名临时表检索结果的select被标记为union result

## TABLE列

这一列显示了对应行正在访问哪个表，在通常情况下，它相当明了：即它显示的就是那个表，或者那个表的别名

但是当from子句中有子查询或有union时，table列会变得复杂得多。

## TYPE列

这一列准确地说是访问类型--换言之就是MySQL决定如何查找表中的行，下面是最重要的访问方式，性能从最差到最优

* ALL：这就是全表扫描，通常意味着MySQL必须扫描整张表，从头到尾，去找到需要的行。（这里也有例外，比如在查询中使用到了limit或者在extra列中显示了using distinct/not exists）
* Index：这跟全表扫描一样，只是MySQL扫描表时是按照索引顺序进行而不是按行进行。它的主要优点是避免了排序；最大缺点是要承担按照索引次序来读取整个表的这个开销，这通常意味着若是按随机次序访问行，开销会非常大。ps：如果在extra列中看到了using index，那么说明MySQL正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行，它比按索引次序全表扫描的开销要少得多
* range：范围扫描就是一个有限制的索引扫描，他开始于索引中的某一点，返回匹配这个值域的行。这比全索引扫描好一点，因为他不用遍历全部索引，当然，范围扫描是带有between或在where子句里带有>的查询。当MySQL使用索引去查找一系列值时，例如in()或者or()列表时，也会显示为范围扫描。然后，这两者其实是相当不同的访问类型，在性能上有重要的差异。此类扫描的开销和索引类型相当
* ref：这是一种索引访问(有时也叫索引查找)，它返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。此类访问只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生，把他叫做ref是因为索引要跟某个参考值相比较，这个参考值通常是一个常数，或者来自多表查询前一个表的结果值。
* eq_ref：使用这种索引查找，MySQL知道最多只返回一条符合条件的记录，这种访问方法可以在MySQL使用主键或者唯一性索引查找时看到，他会将他们与某个参考值做比较。MySQL对这种类型的查找优化的非常好，因为他知道无须估计匹配行的范围或在找到匹配行后再继续查找
* const，system：当MySQL能对查询的某部分进行优化并将其转成一个常量时，他就会使用这类访问方式，举例来说就是，如果你通过将某一行的主键放入where子句里的方式来选取此行的主键，那么MySQL就能把这个查询转换为一个常量，然后就可以高效的将表从联接执行中移除
* null：这种访问方式意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至都用不着再访问表或者索引。例如，从一个索引列中选取最小值可以通过单独查找索引来完成，不需要再执行时访问表

## possible key & key列

possible key：这一列显示了查询可以使用哪些索引，这是基于查询访问的列和使用的比较操作符来判断的。

key：这一列显示了MySQL决定采用哪个索引来优化对该表的访问。如果该索引没有出现在possible key列中，那么MySQL选用它的原因是出于另外的考虑，比如，它选择了一个覆盖索引，哪怕没有where子句。

换句话说，possible key揭示了哪一个索引能有助于高效地进行查找，而key显示的是优化器采用了哪一个索引可以最小化查询成本。

## key_len列

该列显示了MySQL在索引里使用的字节数，如果MySQL正在使用的只是索引里的某些列，那么就可以用这个值来计算出具体是哪些列。MySQL并不总是显示一个索引真正使用了多少。例如，如果对一个前缀模式匹配执行like查询，它会显示列的完全宽度正在被使用。

key_len列显示了在索引字段中可能的最大长度，而不是表中数据使用的实际字节数。换言之，key_len通过查找表的定义而被计算出来的，而不是表中的数据。

## ref列

这一列显示了之前的表在key列记录的索引中查找值所用的列或常量

## rows列

这一列是MySQL估计为了找到所需的行而要读取的行数，这个数字是内嵌循环关联计划里的循环数目，也就是说它不是MySQL认为它最终要从表里读取出来的行数，而是MySQL为了找到符合查询的每一点上标准的那些行而必须读取的行的平均数。

记住，这是MySQL认为它要检查的行数，而不是结果集里的行数。

## filtered列

filtered：它显示的是针对表里符合某个条件(where子句或联接条件)的记录数的百分比所做的一个悲观估算，如果把rows列和这个百分比相乘，就能看到MySQL估算它将和查询计划里前一个表关联的行数

## Extra列

using index：此值表示MySQL将使用覆盖索引，以避免访问表，不要把覆盖索引和index访问类型弄混了

using where：这意味着MySQL服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当他读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示using where，有时using where的出现就是一个暗示：查询可受益于不同的索引。

using temporary：这意味着MySQL在对查询结果排序时会使用到一个临时表

using filesort：MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL有两种文件排序算法，都可以在内存或磁盘上完成。

Range check for each record（index map:N）：这个值意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible key列中索引的位图，并且是冗余的。

