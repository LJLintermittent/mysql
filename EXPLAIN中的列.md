## ID列

这一列总是包含一个编号，标识select所属的行。如果在语句当中没有子查询或者联合查询，那么只会有唯一的SELECT。于是每一行在这个列都将显示一个1

MySQL将select查询分为简单查询和复杂查询，复杂查询可以分为三大类：简单子查询，在from中的子查询和union查询。

注意：MySQL5.6允许解释非select查询。

## SELECT_TYPE列

这一列显示了对应行是简单还是复杂select，（如果是复杂select，那么是三种复杂查询的哪一种）

simple值意味着查询不包括子查询或联合查询，如果查询中有任何复杂的子部分，则最外层部分标记为primary

subquery：包含在select列表中的子查询的中的select（不在from语句中的）

derived：derived用来表示包含在from子句中的子查询中的select，MySQL会递归执行并将结果放到一个临时表，MySQL内部将其称为派生表，因为该临时表是从子查询中派生出来的。

union：在union中的第二个和随后的select被标记为union。

union result：用来从union的匿名临时表检索结果的select被标记为union result

## TABLE列

这一列显示了对应行正在访问哪个表，在通常情况下，它相当明了：即它显示的就是那个表，或者那个表的别名

但是当from子句中有子查询或有union时，table列会变得复杂得多。

## TYPE列

这一列准确地说是访问类型--换言之就是MySQL决定如何查找表中的行，下面是最重要的访问方式，性能从最差到最优

* ALL：这就是全表扫描，通常意味着MySQL必须扫描整张表，从头到尾，去找到需要的行。（这里也有例外，比如在查询中使用到了limit或者在extra列中显示了using distinct/not exists）
* Index：这跟全表扫描一样，只是MySQL扫描表时是按照索引顺序进行而不是按行进行。它的主要优点是避免了排序；最大缺点是要承担按照索引次序来读取整个表的这个开销，这通常意味着若是按随机次序访问行，开销会非常大。ps：如果在extra列中看到了using index，那么说明MySQL正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行，它比按索引次序全表扫描的开销要少得多
* range：范围扫描就是一个有限制的索引扫描，他开始于索引中的某一点，返回匹配这个值域的行。这比全索引扫描好一点，因为他不用遍历全部索引，当然，范围扫描是带有between或在where子句里带有>的查询。当MySQL使用索引去查找一系列值时，例如in()或者or()列表时，也会显示为范围扫描。然后，这两者其实是相当不同的访问类型，在性能上有重要的差异。此类扫描的开销和索引类型相当
* ref：这是一种索引访问(有时也叫索引查找)，它返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。此类访问只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生，把他叫做ref是因为索引要跟某个参考值相比较，这个参考值通常是一个常数，或者来自多表查询前一个表的结果值。
* eq_ref：使用这种索引查找，MySQL知道最多只返回一条符合条件的记录，这种访问方法可以在MySQL使用主键或者唯一性索引查找时看到，他会将他们与某个参考值做比较。MySQL对这种类型的查找优化的非常好，因为他知道无须估计匹配行的范围或在找到匹配行后再继续查找
* const，system：当MySQL能对查询的某部分进行优化并将其转成一个常量时，他就会使用这类访问方式，举例来说就是，如果你通过将某一行的主键放入where子句里的方式来选取此行的主键，那么MySQL就能把这个查询转换为一个常量，然后就可以高效的将表从联接执行中移除
* null：这种访问方式意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至都用不着再访问表或者索引。例如，从一个索引列中选取最小值可以通过单独查找索引来完成，不需要再执行时访问表

## possible key & key列

