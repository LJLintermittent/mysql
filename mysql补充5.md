使用前缀索引前最好使用select count(distinct left(idnex,3/4/5/6/7....)) / count(*) as 1,2,,3,4,5,6,7...

使用这样的sql语句，即使用基数（索引列中不重复的索引值的个数）除以 总记录数来得到这个前缀索引的区分度

区分度越高查找效率越高，能过滤掉更多的行，另外需要注意的是前缀索引无法使用orderby和groupby，当然由于前缀索引不完整，也无法使用覆盖索引来避免回表

如果没有定义主键，innodb会选择一个唯一的非空索引作为替代，如果没有这样的索引， innodb会隐式的定义一个主键来作为聚集索引。

对于聚集索引来说，插入速度严重依赖插入顺序，如果是按照主键递增的顺序来插入，那么是最快的方式，如果不是的话，最好在插入完成以后使用optimize table命令重新组织表

对于聚集索引，每一个叶子节点都包含了主键值，事务id，用于事务和MVCC的回滚指针，以及剩余列

innodb在插入之前不得不先找到并且从磁盘中读取目标页到内存中。如果写入是乱序的，innodb不得不频繁地做页分裂操作，以便为新的行分配空间。所以在使用聚集索引时，尽量使用按照主键的顺序插入数据，并且尽可能的使用单调增加的聚集键的值来插入数据

#### 慢查询优化：

1.优化数据访问：是否向数据库请求了不需要的数据

有些查询会请求超过实际需要的数据， 然后这些多余的数据会被应用程序丢弃，这会给mysql服务器带来额外的负担，并增加网络开销，另外也会消耗服务器的CPU和内存资源

2.响应时间，扫描的行数，返回的行数

在explain语句中的type列反应了访问的类型，访问类型有很多种，从全表扫描到索引扫描，范围扫描，唯一索引扫描，常数引用等，速度从慢到快，扫描的行数也是从多到少

一般mysql使用三种方式来应用where条件：

1.在索引中使用where条件来过滤不匹配的记录，这是在存储引擎层中完成的 

2.使用覆盖索引扫描，extra列出现using index来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，这是在mysql服务器层完成的，但无须再回表查询记录

3.从数据表中返回数据，然后过滤不满足条件的记录，extra中出现using where，这是在mysql服务器层完成的，mysql需要先从数据表中读出记录然后过滤

#### limit查询优化

当系统中需要进行分页操作的时候，通常会使用limit加上偏移量的方式，limit后面可以跟一个参数或者两个参数，如果是跟一个参数，那么代表的是返回多少行，如果是两个参数，那么第一个参数是行偏移量的意思，即要返回的第一行数据从多少行开始计算

那么使用limit最大的问题就是当行偏移量这个参数过大的时候，需要扫描很多的行，最终只返回需要的行，不需要的行都需要被抛弃，代价非常高，这种方式平均需要访问半个表的数据

对于limit的优化思路：

在主查询中写一个子查询，这个子查询只需要查询尽可能少的数据，子查询要带limit条件，一般就是在这个带limit的子查询中只查询出来主键id，然后把这个子查询作为一张临时表temp，在主查询中带上where条件，temp.id = user.id，这样外面的表不论查询哪些字段都是直接使用主键id进行查询，速度会非常快。优化limit的最简单的方式就是使用覆盖索引，而不是查询所有的列

select * from user uc ,(select id from user orderby create_time limit 10000,10) as temp where temp.id  = uc.id;(延迟关联的思想)

select id from user orderby create_time limit 10000,10这一句快的核心原因就在于我查的主键id，这里面会使用create_time的普通索引，那么普通索引的叶子节点不就是主键id，所以这条sql语句一定不需要回表，extra列一定会显示using index，核心的limit操作优化成了不需要回表以后，分页的效果也出来了，因为拿到了分页效果的主键id。那么对于外层查询，主键id直接走主键索引树，也很快就能查到完整的行记录