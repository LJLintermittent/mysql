### 由delete drop引出重建表相关

innodb_file_per_table设置为ON，是推荐做法，表示将每个innodb表数据存储在一个以.ibd结尾的文件中

而且当不需要这个表的时候，通过drop table命令，可以直接删除这个文件，而如果是放在共享表空间中，即使表删除了，空间也是不会回收的

在删除整个表的时候，可以使用drop table命令回收表空间，但是实际遇到的更多的场景是删除其中的记录，这就衍生出一个问题，为什么表中的数据删除了，但是表空间没有被回收

如果使用delete命令删除表中所有的数据，结果是所有的数据页都被标记为可复用，但是磁盘上，文件不会变小，也就是说通过delete不能回收表空间，只是把数据页标记为了可复用，这就感觉像是表中有了一些空洞一样

不只是删除数据会造成空洞，插入数据也会

如果数据是按索引递增顺序插入，那么索引是紧凑的，但是如果是随机插入，那么可能造成索引的页分裂

也就是说经过大量增删改的表，都是可能存在空洞的，如果能把这些空洞去掉，就能达到收缩表空间的目的

重建表就能达到这个目的

重建表的思路是建立一张与表A结构相同的表B，然后将表A的数据按主键索引递增的顺序插入到表B，很显然，表B的主键索引更紧凑，数据页的利用率也更高，如果把表B作为临时表，插入完成以后，用表B替换表A ，就完成了表的重建工作。

但是上面这种做法一个问题，如果在从表A往临时表B中插入数据的时候，表A又有了新的数据，那么重建完成以后还造成更新丢失的情况，所以在插入临时表期间，不可以更新。这是mysql5.6以前的版本，没有online DDL功能

可以通过alter table A engine = innodb

在mysql5.6以后，引入了online DDL，步骤是：

1.建立一个临时文件，扫描表A主键的所在数据页

2.用数据页中表A的记录生成一个B+树，放到临时文件中

3.生成临时文件时，也就是往临时表添加数据的过程中，会把表A的更新操作记录起来，记录到一个叫rowlog 的文件中

4.临时文件生成以后，将日志文件中的操作应用的临时文件，得到一个逻辑上与表A一致的临时表B

5.将表B替换表A，完成重建工作

在线DDL需要在DDL之前拿到MDL写锁，虽然MDL写锁最终会降级成MDL读锁，是可以在DDL期间进行更新操作的，不阻塞更新操作，至于说不直接解锁的原因是为了保护自己，防止其它线程也对这个表做DDL操作，MDL是一个表级锁

对于一个大表来说，重建表最耗时的操作是拷贝数据到临时表的时间，但是这个过程可以接收增删改操作，所以对于整个DDL过程来说，锁的时间只是刚开始获取MDL写锁，然后降级为MDL读锁，做DDL的过程中相当于一直是表级锁MDL的读锁状态，不阻塞，所以业务上看起来就是online DDL，但是即使不阻塞，对于很大的表，这个操作还是很消耗IO和CPU的

inplace概念：

根据表A重建出来的数据是放在temp_file中的，这个临时文件时innodb在内部创建出来的，整个DDL过程都是在innodb内部完成的，对于server层来说，没有把数据挪到临时表，是一个原地操作，这就是inplace名称的来源

mysql5.6开始，alter table t engine = innodb默认就是recreate过程

analyze table ：对表的索引信息做重新统计，没有修改数据，这个过程会加MDL读锁

optimize table等于recreate + analyze

### 关于count(*)

对于不同的存储引擎，count(*)的实现是不同的。

myisam会把一个表的总行数存放在磁盘上，因此执行count(*)的时候直接返回这个数，效率很高

innodb比较麻烦，在执行count(*)的时候，需要把数据一行一行从引擎中取出来，然后累积计数

innodb没有把这个总行数像myisam一样把行数存起来是因为即使是在同一时刻的多个查询，由于多版本并发控制，innodb对于应该返回多少行也是不确定的。

思考这样一个场景：同一时刻有三个会话：

![image](https://cdn.jsdelivr.net/gh/chen-xing/figure_bed_02/cdn/20210903140209854.png)

由于多版本并发控制，不同会话只能读取到当前会话事务开启那一刻的数据快照，并且在同一个事务内，多次读取都是以那个快照版本为准，如果是RR的话，这是可重复读实现的根本依据

那么可以看到对于第一个会话，它开启的时候数据总共有10000行，所以不管这个事务运行了多长时间，最终返回都是10000，会话B比会话A开启的晚，晚到会话C已经插入了一行才开启，这时候读到了这个快照版本，所以在他的事务内，它自己也插入了一条记录，最终读到的就是10002，对于会话C，它在自己的事务内插入一条记录，最终读取的也是自己快照版本+1，最终三个会话在同一时刻在各自的事务内读出来了三个不同的结果

这种情况是跟innodb实现事务有关，RR是默认隔离级别，在代码上通过mvcc多版本并发控制来实现，每一行记录都判断自己是否对这个会话可见，因此count(*)只好把数据一行一行读取出来，可见的行才能用于统计计算

所以由于事务的原因，innodb是无法像myisam一样直接存统计结果，mysql对count(*)是有一定优化的：innodb是索引组织表，主键索引树的叶子节点是整行数据，普通索引树的叶子节点是主键值，所以普通索引树的大小是远小于主键索引树的，但是对这两棵树做数字统计运算的逻辑结果是一致的，因此，mysql会找较小的那颗树进行遍历

count(*)和count（主键id）count（1）都是表示返回满足条件的结果集的总行数，而count（字段），表示返回满足条件的数据行里面，参数字段不为null的总个数

对于count（主键id）来说，innodb会遍历整张表，每一行的id值都取出来，返回给server层，server层拿到id后，判断是不可能为空的，就按行累加

对于count（1）来说，innodb会遍历整张表，但不取值，server层对于返回的每一行，放一个数字1进去，判断是不可能为空的，按行累加

count（1）是比count（主键id）要快，因为引擎层需要返回id涉及到解析数据行，以及拷贝字段值的操作

对于count（字段）来说：由于要判断行记录中的字段，所以肯定需要走主键索引拿到行记录，在行记录中拿到字段，进行null判断

1.如果这个字段是定义为not null，那么就取出所有行中的这个字段，判断不能为null，按行累加

2.如果字段定义允许为null，那么执行的时候判断是否为null，不是null才累加

count(*)做了优化，也就是在索引树较小的树上遍历，并不会直接在主键索引树上遍历，并且取出结果以后不取值，而且肯定不是null，直接累加，按照效率：count（字段）< count（主键id）< count（1）<  count（※）

