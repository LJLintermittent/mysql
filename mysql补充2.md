innodb_file_per_table设置为ON，是推荐做法，表示将每个innodb表数据存储在一个以.ibd结尾的文件中

而且当不需要这个表的时候，通过drop table命令，可以直接删除这个文件，而如果是放在共享表空间中，即使表删除了，空间也是不会回收的

在删除整个表的时候，可以使用drop table命令回收表空间，但是实际遇到的更多的场景是删除其中的记录，这就衍生出一个问题，为什么表中的数据删除了，但是表空间没有被回收

如果使用delete命令删除表中所有的数据，结果是所有的数据页都被标记为可复用，但是磁盘上，文件不会变小，也就是说通过delete不能回收表空间，只是把数据页标记为了可复用，这就感觉像是表中有了一些空洞一样

不只是删除数据会造成空洞，插入数据也会

如果数据是按索引递增顺序插入，那么索引是紧凑的，但是如果是随机插入，那么可能造成索引的页分裂

也就是说经过大量增删改的表，都是可能存在空洞的，如果能把这些空洞去掉，就能达到收缩表空间的目的

重建表就能达到这个目的

重建表的思路是建立一张与表A结构相同的表B，然后将表A的数据按主键索引递增的顺序插入到表B，很显然，表B的主键索引更紧凑，数据页的利用率也更高，如果把表B作为临时表，插入完成以后，用表B替换表A ，就完成了表的重建工作。

但是上面这种做法一个问题，如果在从表A往临时表B中插入数据的时候，表A又有了新的数据，那么重建完成以后还造成更新丢失的情况，所以在插入临时表期间，不可以更新。这是mysql5.6以前的版本，没有online DDL功能

可以通过alter table A engine = innodb

在mysql5.6以后，引入了online DDL，步骤是：

1.建立一个临时文件，扫描表A主键的所在数据页

2.用数据页中表A的记录生成一个B+树，放到临时文件中

3.生成临时文件时，也就是往临时表添加数据的过程中，会把表A的更新操作记录起来，记录到一个叫rowlog 的文件中

4.临时文件生成以后，将日志文件中的操作应用的临时文件，得到一个逻辑上与表A一致的临时表B

5.将表B替换表A，完成重建工作

在线DDL需要在DDL之前拿到MDL写锁，虽然MDL写锁最终会降级成MDL读锁，是可以在DDL期间进行更新操作的，不阻塞更新操作，至于说不直接解锁的原因是为了保护自己，防止其它线程也对这个表做DDL操作，MDL是一个表级锁

对于一个大表来说，重建表最耗时的操作是拷贝数据到临时表的时间，但是这个过程可以接收增删改操作，所以对于整个DDL过程来说，锁的时间只是刚开始获取MDL写锁，然后降级为MDL读锁，做DDL的过程中相当于一直是表级锁MDL的读锁状态，不阻塞，所以业务上看起来就是online DDL，但是即使不阻塞，对于很大的表，这个操作还是很消耗IO和CPU的

inplace概念：

根据表A重建出来的数据是放在temp_file中的，这个临时文件时innodb在内部创建出来的，整个DDL过程都是在innodb内部完成的，对于server层来说，没有把数据挪到临时表，是一个原地操作，这就是inplace名称的来源

mysql5.6开始，alter table t engine = innodb默认就是recreate过程

analyze table ：对表的索引信息做重新统计，没有修改数据，这个过程会加MDL读锁

optimize table等于recreate + analyze

