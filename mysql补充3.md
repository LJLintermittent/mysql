### mysql高可用架构

#### mysql的双1模式

~~~wiki
innodb_flush_log_at_trx_commit和sync_binlog 两个参数是控制MySQL 磁盘写入策略以及数据安全性的关键参数。

innodb_flush_log_at_trx_commit如果设置为0，表示log buffer将每秒一次写入到磁盘中，并且将log file page cache进行fsync，这个操作会同时进行。在该模式下，事务的提交不会主动触发写入磁盘的操作，如果设置为1，表示每次事务提交的时候都要进行log buffer往磁盘写入的操作，并且会fsync，如果设置为2，表示每次事务提交都会将buffer写入file，但是不flush，在这个模式下会每秒执行一次fsync

如果设置为0，在由于每秒一次的logbuffer写入，说明在这段时间数据都是在内存中的，所以这种模式既没办法满足mysql实例进程的crash-safe，也无法满足os的crash-safe，在最极端情况下可能会造成损失上一秒的所有数据

如果设置为1，每次提交都会提交到file cache，并且还会调用os的filecaceh flush操作，所以可以保证mysql的crash和os的crash

如果设置为2，每次提交都会写cache，这个写cache再次强调一遍，是把buffer中的内容写到操作系统的文件系统中的文件缓存中。每次提交都会写cache但是不会立即调用文件系统的flush操作，所以可以保证mysql的crash-safe，但是不能保证os的crash-safe

如果对系统的磁盘io能力很自信，同时需要满足数据的强一致性需求，不能容忍任何mysql crash和os crash，那么就是用1模式

sync_binlog 的默认值是0，像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统来刷新binary log。 当sync_binlog =N (N>0) MySQL 在每写 N次 二进制日志binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步到磁盘中去

sync_binlog 为0时：当事务提交以后，os中的文件系统不会进行fsync调用，而让文件系统自行决定什么时候让文件缓存真正写到文件中，比如说cache满了的时候，所以如果os crash，会发生数据丢失

当为1时，事务只要提交，那么binlog会先从binlogbuffer写到os的binlog file的cache，然后会立即flush，可以保证数据的完全准备性，当然不可避免的是磁盘io的损失

所谓的双1模式就是每次事务提交不仅会做到redolog的最终落盘，还要保证binlog的最终落盘
~~~

当innodb_flush_log_at_trx_commit和sync_binlog 都为 1 时是最安全的，在mysql服务崩溃crash的时候，binlog只有可能丢失最多一个语句或者一个事务，但是双1模式会导致频繁的io操作，因此这个模式也是最慢的一种

正常情况下，只要主库执行更新生成所有的binlog，都可以传到备库并被正确的执行，备库就能达到跟主库一致的状态，这就是最终一致性，但是mysql要提供高可用的能力，只有最终一致性的是不够的。

双M结构的主备切换流程：

主备切换可能是一个运维动作，比如软件升级，主库所在机器定时下线等，也可能是被动操作，比如主库所在机器掉电

主备延迟：

1.主库A执行完一个事务，写入binlog，把这个时间作为T1

2.从库读取binlog，把这个binlog接收完毕这是时刻称为T2

3.从库B执行完这个事务，这个时刻称为T3

所谓的主备的延迟就是这个T3 - T1，备库执行show slave status可以通过参数列表查看当前系统的差值，至于两个库的系统时间不一致这个问题，其实不用担心，备库在连接入主库时，会从主库获取它的系统时间，需要注意的是，在网络正常的情况下，主库将日志打入从库这个时间延迟是很低的，主要时间会花费在从库接收和执行binlog这个时间，所以主备延迟最直接的表现是，备库消费中转日志relay log的速度，比主库生产binlog的速度要慢。

主备延迟的来源：

1.备库机器的性能低于主库，其实更新请求对于IOPS的压力，在主库和备库上是没有差别的，所以在做部署的时候，一般都会将备库设置为非双1模式

2.备库压力过大，主库主要提供写能力，从库提供查询能力，这种可以使用一主多从的架构，除了主备以外，再来几个从库，分担备库的读压力

3.大事务，主库上必须等待事务执行完才会写入binlog，再传给备库，典型的就是一次delete过多的数据，另一种典型的大事务场景是大表的DDL，这种如果真的有业务需求需要对线上的业务表进行在线DDL，可以使用gh-ost方案，也是一种online DDL

### mysql误删数据的处理

如果使用delete语句误删除了数据行，可以用flushback工具通过闪回将数据进行恢复，恢复的原理是：修改binlog日志内容，拿回原库进行重放，但是这种方式的前提是binlog的格式必须是row格式，并且binlog_row_image = full，binlog日志的前镜像只记录唯一识别列(唯一索引列、主键列)，后镜像只记录修改列，而binlog_row_image = full表示前镜像和后镜像都开启

具体恢复的过程是：

1.对于insert语句，对应的binlog是write_rows_event，把他改成delete_rows_event即可

2.对于delete语句，改成write即可

3.如果是update，binlog里面记录了数据行修改前和修改后的值，对调这两行位置即可

如果误删涉及多个事务，还需要将事务的顺序调过来执行，但是在恢复的过程中一般不会在主库上进行，会找一个库作为临时库，在这个临时库执行这些操作，然后通过确认后再恢复回主库

这是对于误删数据的事后处理方式，更重要的是做好事前预防。

1.可以将sql_safe_updates设置为on，这样如果忘记在delete后面跟where语句，或者where条件里面没有包含索引字段的话，这条语句执行会直接报错，但是如果业务上真的有删除一个小表中所有数据的需求时，可以使用delete from t where id >=0的方式来删除所有数据

2.代码上线前，要做好sql审计

使用delete删除的语句，可以使用flushback来借助binlog进行恢复，但是truncate和drop删除后无法通过flushback来进行恢复，注意这俩还是DDL，也就是执行会隐式提交事务，对于truncate和drop，即使binlog是row格式，执行这俩命令binlog还是statement格式，statement格式格式的binlog只记录了这俩的sql语句，对于恢复没有任何帮助

这种情况下，就需要使用全量备份和增量日志来恢复数据，这个方案要求线上有定期的全量备份，并且实时备份增量日志binlog

在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：

1. 取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；
2. 用备份恢复出一个临时库；
3. 从日志备份里面，取出凌晨0点之后的日志；
4. 把这些日志，除了误删除数据的语句外，全部应用到临时库。

关于全量备份和增量日志的恢复方案，需要注意以下两点：

1.为了加速数据恢复，如果这个临时库上有多个数据库，可以使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况，因为增量日志会记录所有库的日志信息，而我们只需要误删表所在的那个库的增量日志

2.注意不要带上误删的语句

预防误删库方案：

只给业务开发同学DML权限，而不给DDL权限，即使是DBA成员，日常也只能使用只读权限的账号，必要时才使用有更新权限的账号

指定删库的流程规范：

如果确实有业务需要删除整张表的所有数据，在删除表之前，可以先把表名改了，然后让业务跑一段时间，看有没有影响，相当于逻辑上这个表没了，看整个业务系统有没有影响，确定了以后再回来真正删除

至于rm删除mysql实例，其实对于高可用的mysql集群并且带有HA系统，最不怕的就是rm，只要不是一个一个把整个集群删了，只是删了一个节点的话，HA系统会开始工作，找出一个新的主库

永远记住，删除的操作预防的意义远大于处理