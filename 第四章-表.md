# 《MySQL技术内幕：InnoDB存储引擎》

## 第四章 表

本章将从InnoDB存储引擎表的逻辑存储以及实现开始总结，然后将重点分析表的物理存储特征，即数据是如何在表中进行组织和存放的。

简单来说，表就是关于特定实体的数据集合，这是关系型数据库模型的核心。

### 索引组织表

在InnoDB存储引擎中，表都是根据主键顺序组织存放的。这种存储方式的表称为索引组织表，在InnoDB存储引擎表中，每张表都有个主键，如果在创建表的时候没有显示的指定主键，那么存储引擎会按照一定的规则来选择和创建索引

* 首先判断表中是否存在非空的唯一索引，如果有，则该列作为主键
* 如果不符合上述条件，InnoDB存储引擎会自动创建一个6字节大小的指针

当表中有多个非空的唯一索引时，InnoDB存储引擎会选择建表时第一个定义的非空唯一索引来作为主键，注意主键的选择是根据索引建立的顺序，而不是列的定义顺序

### InnoDB逻辑存储结构

从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个共享表空间中，这个表空间是由段，区，页组成。

### 表空间

表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有数据都存放在表空间中，在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1，即所有数据都存在这个表空间中，如果用户启用innodb_file_per_table参数，则每张表内的数据可以单独放到一个表空间中。

但是需要注意的是，这个单独的表空间只存放数据，索引和插入缓冲bitmap页，其他类的数据，如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等都还是存放在原来的共享表空间中，这也就是说，即使开启了独立表空间参数，共享表空间的大小依然会增加。

### 段

表空间是由各个段组成的，常见的段有数据段，索引段和回滚段，由于InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。那么数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。回滚段较为特殊，后面将会介绍。

InnoDB存储引擎中，对段的管理都是由引擎自身完成的。

### 区

区是由连续的页组成的，在任何情况下每个区的大小都为1MB，为了保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4-5个区，在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中有连续64个页。

InnoDB存储引擎后面的版本也引入了压缩页，可以通过参数来对页的大小进行设置。

后面又添加了一个参数innodb_page_size来改变默认的页大小，但是这时页中的数据库不是压缩。

这里有一个小问题，在用户开启了独立表空间参数后，创建的表默认大小是96KB，区中是连续的64个页，那么创建的表的大小至少应该是1MB才对？其实是因为在每个段开始时先用32个页大小的碎片页来存放数据，在使用完以后才申请连续的64个页，这样做的目的是对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

### 页

同大多数数据库一样，InnoDB存储引擎也有页的概念，页是InnoDB存储引擎磁盘管理的最小单位。在InnoDB存储引擎中，页的大小默认为16KB。

在InnoDB存储引擎中，常见的页类型有：

* 数据页(B-tree Node)
* undo页(undo Log Node)
* 系统页(System Node)
* 事务数据页(Transaction system Page)
* 插入缓冲位图页
* 插入缓冲空闲列表页
* 未压缩的二进制大对象页
* 压缩的二进制大对象页

### 行

InnoDB存储引擎是面向列的，也就是数据是按照行进行存放的，每个页存放的行记录是有硬性定义的，最多允许存放16KB/2- 200行的记录，也就是7992行记录。

### InnoDB行记录格式

InnoDB存储引擎和大多数数据库一样，记录是以行的形式进行存储的。这意味着页中保存着表中一行行的数据。在老版本，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。其中Redundant是为了兼容老版本而保留的一种格式。

### Compact行记录格式

这种行记录格式的设计目标是高效地存储数据，简单来说，一个页中存放的行数据越多，其性能就越高。

Compact行记录的存储格式如下：

变长字段长度列表--NULL标志位--记录头信息--列2数据--列2数据。。。

变长字段的长度最大不超过两个字节，这是因为在MySQL数据库中varchar类型的最大长度限制为65535.

注意，每行数据除了用户定义的以外，还有两个隐藏的列，事务ID列和回滚指针列，分别为6字节和7字节，若InnoDB存储引擎没有定义主键，还有一个6字节的rowid列。

### 行溢出数据

InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOB，LOB这类的大对象列类型的存储会把数据放在数据页面之外。但是即便是varchar类型的数据列，也可能会被存放为行溢出数据。

通过实际测试发现在latin1字符集设置下，能存放varchar类型的最大长度为65532，而不是65535，但是将字符集设置为GBK或者UTF-8，那么这次创建varchar(65532)依然会报错，从中我们可以理解varchar类型的(N)中的N指的是字符的长度，而文档中说明varchar类型最大支持65535，单位是字节。

此外还需要注意的是MYSQL官方手册定义的65535长度指的是varchar列的长度总和，如果列的长度综合超过这个长度，那么依然会报错

~~~sql
create table test(
    a varchar(22000),
	b varchar(22000),
	c varchar(22000)
	)charset=latin1,engine=InnoDB;
~~~

在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree Node中，但是当发生溢出时，数据存放在页类型为Uncompress Blob页中。

InnoDB存储引擎表是索引组织的，即B+tree结构，这样每个页中至少应该有两条行记录，否则就失去了B+tree的意义，变成链表了，因此如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据放到溢出页中。

### compressed和Dynamic行记录格式

新的两种行记录格式对于存放在BLOB中的数据采用了完全的行溢出方式。

### char的行结构存储

通常理解varchar是存储变长长度的字符类型，char是存储定长长度的字符类型。

然而值得注意的是，char(N)中的N指的是字符的长度，而不是字节大小，也就是说在不同字符集下，char类型列内部存储的可能不是定长的数据。比如对于GBK字符集，当我们存储两个字符 'aa' 和 '我们' 时，这两个记录的字符长度都是2，但是内部存储上前者占用2字节，后者占用4字节，因此对于多字节的字符编码，char类型不再代表固定长度的字符串，例如对于UTF-8下的char(10)类型的列，其最小可以存储10字节的字符，最多可以存储30字节的字符。因此对于多字节字符编码的char数据类型的存储，InnoDB存储引擎在内部会将其视为变长字符类型，这也就意味着在变长长度列表中会记录char类型的长度。因此可以认为在多字节字符集的情况下，char和varchar的实际行存储基本是没有区别的。

### InnoDB数据页结构

InnoDB数据页由以下七个部分组成：

* File Header 文件头
* Page Header 页头
* Infimun和supremum Records 虚拟的行记录，用来限定记录的边界
* User Records 用户记录，即行记录
* Free Space 空闲空间
* Page Directory 页目录
* File Trailer 文件结尾信息

B+树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页，数据库把页加载的内存，然后通过Page directory进行二叉查找，只不过二叉查找的时间复杂度很低，同时在内存中查找很快，因此忽略这部分查找所用的时间。

### 约束

关系型数据库和文件系统的一个不同点是：关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。一般来说，数据完整性有以下三种形式：

* 实体完整性保证表中有一个主键，在InnoDB存储引擎表中，用户可以通过定义primary key和unique key约束来保证实体的完整性。用户还可以编写一个触发器来保证数据的完整性。
* 域完整性保证数据每列的值满足特定的条件，在InnoDB存储引擎中，域完整性可以通过1.选择合适的数据类型来确保一个数据值满足特定的条件2.外键约束3.触发器4.使用default约束作为强制域完整性的一个方面
* 参照完整性保证两张表之间的关系，InnoDB存储引擎支持外键，因此允许用户定义外键以强制参照完整性。

就InnoDB存储引擎本身而言，提供了以下几种约束：

* primary key
* unique key
* Foreign key
* Default
* Not NULL

### 约束和索引的区别

当用户创建了一个唯一索引就看着像是创建了一个唯一约束，但是约束和索引的概念还是有些不同的，约束更是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。

mysql数据库不支持传统的check约束，但是通过enum和set类型可以解决部分这样的约束需求

### 触发器与约束

触发器的作用是在执行insert，delete，update操作之前或者之后自动调用一个sql命令或存储过程，最多可以为一个表建立6个触发器，分别是insert，delete，update三种操作的before和after操作。注意mysql数据库只支持按每行记录进行触发。

### 外键约束

外键是用来保证参照完整性的，在orcal数据库中，对于建立外键的列，一定不要忘记给这个列加上一个索引，而InnoDB存储引擎在外键建立时会自动地为该列加一个索引，这样可以很好的避免外键列上无索引而导致的死锁问题的产生。

对于参照完整性，外键能起到一个非常好的作用，但是对于数据的导入操作，外键往往导致在外键约束的检查上花费大量时间，因为mysql数据库的外键是即时检查的，所以对导入的每一行都会进行外键检查。

### 视图

在mysql数据库中，视图是一个命名的虚表，它由一个sql查询来定义，视图可以当做表来使用，与持久表不同，视图中的数据没有实际的物理存储。

视图在数据库中发挥着重要的作用，视图的主要用途之一被当做一个抽象装置，特别是对于一些应用，程序本身不关心基表的结构，只需要按照视图定义来获取数据或更新数据，因此，视图在一定程度上起到一个安全层的作用。虽然视图是基于基表的一个虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基本表。一般称可更新的视图为可更新视图。

### 物化视图

orcal数据库支持物化视图，这个视图不再是基于基表的虚表，而是根据基表实际存在的实表，即物化视图的数据存储在非易失的存储设备上，物化视图可以用于预先计算并保存多表的连接(join)或者聚合(group by)等耗时较多的sql操作结果。

mysql数据库不支持物化视图，换句话说，mysql数据库中的视图总是虚拟的，但是用户可以通过一些机制来实现物化视图的功能，比如可以通过触发器等来实现。

### 分区表

