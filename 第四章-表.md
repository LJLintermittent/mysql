# 《MySQL技术内幕：InnoDB存储引擎》

## 第四章 表

本章将从InnoDB存储引擎表的逻辑存储以及实现开始总结，然后将重点分析表的物理存储特征，即数据是如何在表中进行组织和存放的。

简单来说，表就是关于特定实体的数据集合，这是关系型数据库模型的核心。

### 索引组织表

在InnoDB存储引擎中，表都是根据主键顺序组织存放的。这种存储方式的表称为索引组织表，在InnoDB存储引擎表中，每张表都有个主键，如果在创建表的时候没有显示的指定主键，那么存储引擎会按照一定的规则来选择和创建索引

* 首先判断表中是否存在非空的唯一索引，如果有，则该列作为主键
* 如果不符合上述条件，InnoDB存储引擎会自动创建一个6字节大小的指针

当表中有多个非空的唯一索引时，InnoDB存储引擎会选择建表时第一个定义的非空唯一索引来作为主键，注意主键的选择是根据索引建立的顺序，而不是列的定义顺序

### InnoDB逻辑存储结构

从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个共享表空间中，这个表空间是由段，区，页组成。

### 表空间

表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有数据都存放在表空间中，在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1，即所有数据都存在这个表空间中，如果用户启用innodb_file_per_table参数，则每张表内的数据可以单独放到一个表空间中。

但是需要注意的是，这个单独的表空间只存放数据，索引和插入缓冲bitmap页，其他类的数据，如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等都还是存放在原来的共享表空间中，这也就是说，即使开启了独立表空间参数，共享表空间的大小依然会增加。

### 段

表空间是由各个段组成的，常见的段有数据段，索引段和回滚段，由于InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。那么数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。回滚段较为特殊，后面将会介绍。

InnoDB存储引擎中，对段的管理都是由引擎自身完成的。

### 区

区是由连续的页组成的，在任何情况下每个区的大小都为1MB，为了保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4-5个区，在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中有连续64个页。

InnoDB存储引擎后面的版本也引入了压缩页，可以通过参数来对页的大小进行设置。

后面又添加了一个参数innodb_page_size来改变默认的页大小，但是这时页中的数据库不是压缩。

这里有一个小问题，在用户开启了独立表空间参数后，创建的表默认大小是96KB，区中是连续的64个页，那么创建的表的大小至少应该是1MB才对？其实是因为在每个段开始时先用32个页大小的碎片页来存放数据，在使用完以后才申请连续的64个页，这样做的目的是对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

### 页

同大多数数据库一样，InnoDB存储引擎也有页的概念，页是InnoDB存储引擎磁盘管理的最小单位。在InnoDB存储引擎中，页的大小默认为16KB。

在InnoDB存储引擎中，常见的页类型有：

* 数据页(B-tree Node)
* undo页(undo Log Node)
* 系统页(System Node)
* 事务数据页(Transaction system Page)
* 插入缓冲位图页
* 插入缓冲空闲列表页
* 未压缩的二进制大对象页
* 压缩的二进制大对象页

### 行

InnoDB存储引擎是面向列的，也就是数据是按照行进行存放的，每个页存放的行记录是有硬性定义的，最多允许存放16KB/2- 200行的记录，也就是7992行记录。

### InnoDB行记录格式

InnoDB存储引擎和大多数数据库一样，记录是以行的形式进行存储的。这意味着页中保存着表中一行行的数据。在老版本，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。其中Redundant是为了兼容老版本而保留的一种格式。

### Compact行记录格式

这种行记录格式的设计目标是高效地存储数据，简单来说，一个页中存放的行数据越多，其性能就越高。

Compact行记录的存储格式如下：

变长字段长度列表--NULL标志位--记录头信息--列2数据--列2数据。。。

变长字段的长度最大不超过两个字节，这是因为在MySQL数据库中varchar类型的最大长度限制为65535.

注意，每行数据除了用户定义的以外，还有两个隐藏的列，事务ID列和回滚指针列，分别为6字节和7字节，若InnoDB存储引擎没有定义主键，还有一个6字节的rowid列。

### 行溢出数据

InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOB，LOB这类的大对象列类型的存储会把数据放在数据页面之外。但是即便是varchar类型的数据列，也可能会被存放为行溢出数据。

通过实际测试发现在latin1字符集设置下，能存放varchar类型的最大长度为65532，而不是65535，但是将字符集设置为GBK或者UTF-8，那么这次创建varchar(65532)依然会报错，从中我们可以理解varchar类型的(N)中的N指的是字符的长度，而文档中说明varchar类型最大支持65535，单位是字节。

此外还需要注意的是MYSQL官方手册定义的65535长度指的是varchar列的长度总和，如果列的长度综合超过这个长度，那么依然会报错

~~~sql
create table test(
    a varchar(22000),
	b varchar(22000),
	c varchar(22000)
	)charset=latin1,engine=InnoDB;
~~~

在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree Node中，但是当发生溢出时，数据存放在页类型为Uncompress Blob页中。

InnoDB存储引擎表是索引组织的，即B+tree结构，这样每个页中至少应该有两条行记录，否则就失去了B+tree的意义，变成链表了，因此如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据放到溢出页中。

### compressed和Dynamic行记录格式

新的两种行记录格式对于存放在BLOB中的数据采用了完全的行溢出方式。

### char的行结构存储

通常理解varchar是存储变长长度的字符类型，char是存储定长长度的字符类型。

然而值得注意的是，char(N)中的N指的是字符的长度，而不是字节大小，也就是说在不同字符集下，char类型列内部存储的可能不是定长的数据。比如对于GBK字符集，当我们存储两个字符 'aa' 和 '我们' 时，这两个记录的字符长度都是2，但是内部存储上前者占用2字节，后者占用4字节，因此对于多字节的字符编码，char类型不再代表固定长度的字符串，例如对于UTF-8下的char(10)类型的列，其最小可以存储10字节的字符，最多可以存储30字节的字符。因此对于多字节字符编码的char数据类型的存储，InnoDB存储引擎在内部会将其视为变长字符类型，这也就意味着在变长长度列表中会记录char类型的长度。因此可以认为在多字节字符集的情况下，char和varchar的实际行存储基本是没有区别的。

### InnoDB数据页结构

