### mysql的内部临时表

union的语义是取出这两个子查询的并集，并集的意思就是两个子查询的结果相加，重复的只添加一行

对子查询的结果做union的时候，使用explain分析后会看到Using temporary，表示使用了内部临时表，整个语句的执行流程是这样的：

(select 1000 as f) union (select id from t1 order by id desc limit 2);

1.创建一个临时表，这个临时表只有一个整型字段f，并且f是主键

2.执行第一个子查询，并将结果存入临时表

3.执行第二个子查询，试图将结果插入临时表，如果这个值已经在临时表中存在了，那么就违反了union的唯一性约束，所以插入失败，然后继续执行

4.从临时表中取出数据，返回结果，并删除临时表

如果把union改为了union all，没有了去重的概念后，这样在执行的时候直接执行两个子查询，然后将结果进行返回，这个过程不会使用到临时表，所以explain中没有Using temporary

group by也会出现Using temporary，不论是内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。

group by的逻辑语义是：统计不同的值出现的个数。如果每一行的结果都是无序的，那就需要有一个临时表，来记录并统计结果，那么扫描过程如果可以保证出现的数据是有序的，就不需要临时表了

1.如果对group by语句的结果没有排序需求，要在语句后面加order by null

2.尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort

3.如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；

4.如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果

InnoDB和Memory引擎的数据组织方式是不同的：

InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为**索引组织表**（Index Organizied Table）。

而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为**堆组织表**（Heap Organizied Table）。

### 自增主键为什么不是连续的？

什么情况下自增主键会出现空洞？

唯一键的冲突可能会导致自增主键id不连续

假设表中已经有了一条记录(1,1,1)，insert into t values(null, 1, 1)，并且表中有字段加了唯一索引。 这个语句的执行流程如下：

1.执行器调用innodb接口写入一行，传入的这一行的值为(0,1,1)

2.innodb发现用户没有执行自增id的值，获取当前表的自增值是2

3.将传入的值改为（2,1,1）

4.将表的自增值改为3，为下一次插入以后主键的自增做准备

5.执行插入操作，如果有字段佳乐唯一索引，那么会判断已经存在了，所以插入失败，但是这个表的当前自增值已经到了3了

其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看**自增值为什么不能回退。**

假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。

1. 假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。
2. 事务B正确提交了，但事务A出现了唯一键冲突。
3. 如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id=3的行，而当前的自增id值是2。
4. 接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入语句报错“主键冲突”。

而为了解决这个主键冲突，有两种方法：

1. 每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。
2. 把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。

可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增id回退”的前提导致的。

因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的，另外在innodb存储引擎中，自增值会记录在内存中，并且mysql直到8.0以后才给innodb表的自增值加上了持久化的能力，确保重启前后一个表的自增值不变

### 分区表

分区表包含一个.frm文件和K个.ibd文件，每个分区对应一个.ibd文件，对于存储引擎来说，有几个分区就相当于有几个表，所以这块在间隙锁的时候需要注意，数据是有可能在间隙插入成功的，因为对于引擎层，这是不同的表。

分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的代码更简洁，还有分区表可以很方便的清理历史数据

