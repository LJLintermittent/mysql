# 《MySQL技术内幕：InnoDB存储引擎》

## 第六章 锁

### 前言

开发多用户，数据库驱动的应用时，最大的一个难点是：一方面要最大程度的利用数据库的并发访问，另一方面还要确保每个用户能以一致的方式读取和修改数据，为此就有了锁机制。同时这也是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问，InnoDB存储引擎会在行级别上对表数据上锁。

对于myisam引擎，其锁是表锁设计，并发情况下的读没有问题，但是并发插入时的性能就要差一些了。

InnoDB存储引擎的实现和orcal数据库非常类似，提供一致性的非锁定读，行级锁支持。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。

### lock和latch

latch：模式为：读写锁，互斥量。一般被称为轻量级的锁，因为其要求锁定的时间非常短，若持续的时间长了，应用的性能会变得很差。在InnoDB存储引擎中，latch又分为mutex(互斥量)与rwlock(读写锁)，其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁的检测机制。

lock：模式为：行锁，表锁，意向锁。lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行等。并且一般lock的对象仅在事务commit或rollback后进行释放，(不同事务的隔离级别释放的时间可能不同)，lock锁通过waits-for-graph，time-out机制来进行死锁检测和处理。

### InnoDB存储引擎中的锁

锁的类型：InnoDB存储引擎实现了如下两种标准的行级锁：

* 共享锁（S Lock），允许事务读一行数据
* 排他锁（X Lock），允许事务删除或更新一行数据

读锁仅与读锁兼容，写锁与任何锁都不兼容。

此外，InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁与表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称为意向锁，意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

### 一致性非锁定读

一致性的非锁定读是InnoDB存储引擎通过多版本并发控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或update操作，这时读取操作不会因此去等待行上锁的释放，相反地，InnoDB存储引擎会去读取行的一个快照数据

之所以称为非锁定读，因为不需要等待访问的行上排他锁的释放，快照数据是指改行的之前的版本，该实现是通过undo段来完成，而undo用来在事务中回滚数据，因此快照数据本身是没有额外开销的。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作（历史不可篡改）。

一致性非锁定读极大地提高了数据库的并发性。在InnoDB存储引擎的默认设置下，这是默认的读取方式。即读取不会占用和等待表上的锁。

但是在不同的事务隔离级别下，读取的方式是不同的。

快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为多版本并发控制。

在读已提交和可重复读隔离级别下，InnoDB存储引擎使用非锁定的一致性读。然而他们对于快照数据的定义是不同的。在读已提交下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在可重复读下，对于快照数据，一致性非锁定读总是读取事务开始时的行数据版本。

### 一致性锁定度

在默认配置下，InnoDB存储引擎的事务隔离级别为可重复读，这个时候InnoDB存储引擎的select操作使用一致性非锁定读，但是在某些情况下，用户需要显示地对数据库读取操作进行加锁以保证数据库逻辑的一致性。而这要求数据库支持加锁语句，即使是对于select的只读操作，InnoDB存储引擎对于select语句支持两种一致性锁定读操作：

* select....for update
* select ...lock in share mode

select....for update对读取的行记录加一个X锁，其他事务不能对已锁定的行记录加上任何锁。

select ...lock in share mode对读取的行记录加上一个S锁，其他事务可以向被锁定的行记录再加S锁，但是不能加X锁，会被阻塞。

对于一致性非锁定读，即使读取的行记录上加了显示的锁，比如select....for update，也是可以进行读取的，只不过读取的是行上的一个快照数据。此外select....for update，select ...lock in share mode必须在一个事务中，当事务提交了，锁也就释放了。因此在使用上述两个语句时，必须加上begin，start transaction或者set autocommit = 0

### 自增长与锁

自增长在数据库中是一种非常常见的属性，也是很多开发人员首选的一种主键方式，在InnoDB存储引擎内部，对于每一个含有自增长值的表都有一个自增长计数器，插入操作通过这个自增长的计数器值加一来赋予自增长列。这个实现方式叫auto-inc-locking。这种锁采用的是一种优化后的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放的，而是在完成对自增长值插入的sql语句后立即释放。

这种机制从一定程度上提高了并发性，但是在并发插入上性能依然较差，事务必须等待前一个事务中的sql语句执行完了才可以插入。

特别注意：

InnoDB存储引擎中的自增长的实现与myisam不同，myisam引擎采用的是表锁设计，自增长不需要考虑并发插入的问题。

对于主从架构采用不同存储引擎的方案，需要特别注意。

同时注意：

对于InnoDB存储引擎，自增长的列必须是索引，同时必须是索引的第一个列。myisam没有这个要求。

### 外键和锁

外键主要用于引用完整性的约束检查，在InnoDB存储引擎中，对于一个外键列，如果没有显示地为外键列加索引，InnoDB存储引擎会自动地为外键列加一个索引，因为这样可以避免表锁。（死锁？？）

对于外键值的插入或更新，首先需要查询父表的记录，即select 父表，但是对于父表的select操作，因为这时使用的是select lock in share mode方式。即主动对父表加了一个S锁，如果这时父表已经加了X锁，子表上的操作会被阻塞的。

设想一下如果访问父表时使用的是一致性非锁定读，那么会读到快照数据，如果满足插入条件，那么就直接插入了啊！但是如果另一个会话把这个记录删掉了，并且提交了，则父表中就并不存在这个数据了，造成了数据在子表，父表不一致的情况。

总之，生产级应用禁止使用外键，一切约束在应用层来实现。

