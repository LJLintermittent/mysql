# 《MySQL技术内幕：InnoDB存储引擎》

## 第七章 事务

### 前言

事务是数据库系统区别于文件系统的重要特性之一。

事务会把数据库从一种一致状态转换到另一种一致状态。在数据库提交工作时，可以确保要么所有的修改都已经完成了，要么所有的修改都没有做，并且保存了事务开始前的状态，以便可以回到开始的状态。

InnoDB存储引擎中的事务完全符合ACID四大特性的

* 原子性 atomicity
* 一致性 consistency
* 隔离性 isolation
* 持久性 durability

上一章总结了锁，锁是InnoDB存储引擎实现隔离性的重要保证。本章主要关注事务原子性这一概念。

### 事务概述

事务可由一条SQL语句组成，也可以由多条SQL语句组成。事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务的操作中，要么都做修改，要么都不做，这就是事务的目的。也是事务模型区别于文件系统的重要特征之一。

理论上来说，事务有着极其严格的定义，即通常所说的四大特性。但是值得注意的是，虽然理论上定义了严格的要求，但是各种数据库厂商在开发的时候并没有严格去满足事务的ACID标准，例如对于orcal数据库来说，它的隔离级别是RC，并没有满足隔离性要求，不过在大多数情况下，这并不会导致严重的后果，甚至可能带来性能上的提升。但是作为开发者，我们要知道事务的标准，对于InnoDB存储引擎而言，它的事务是完全严格符合ACID标准的事务。

**A atomicity 原子性**：在计算机系统中，每个人都将原子性视为理所当然。然后在数据库的事务中实现调用操作的原子性，就不是那么理所当然了。

~~~wiki
例如：ATM存取款例子
1.登录ATM平台，验证密码
2.从远程银行的数据库中，取得账户的信息
3.用户在ATM机上输入欲取出的金额
4.从远程银行的数据库中，更新账户信息
5.ATM出款
6.用户取到了钱
~~~

整个过程应该视为原子操作，即要么都做，要么都不做，不能发生用户钱没取到，但是账户余额更新了的情况。原子性是指事务是一个不可分割的执行单元。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句都必须撤销，数据库状态应该退回到执行事务前的状态。

如果事务中都是只读的操作，要保持事务的原子性是很简单的，一旦发生任何错误，要么重试，要么返回错误代码。因为只读操作不会影响数据库中的任何部分。如果涉及插入或更新或删除操作，那么就需要保证当发生错误时数据库的状态应该退回事务开始前的状态。

**C consistency 一致性**：一致性是指事务将数据库从一种一致性状态转换到另一种一致性状态。在事务开始前和事务结束后，数据的完整性约束没有被破坏。例如，在一个表中有一个字段为名字，为唯一约束，即在表中姓名不能重复。如果一个事务对姓名字段进行了修改，但是在事务提交或事务操作发生回滚后，表中的姓名变得非唯一了，这就破坏了事务的一致性要求。因此，事务是一致性的单位，如果事务中某个工作失败了，系统可以自动撤销事务---返回初始状态。

**I isolation 隔离性：** 隔离性还有其他称呼，如并发控制，可串行化，锁等。事务的隔离性要求每个读写事务的对象对其他事物的操作对象能相互分离，即该事务提交前对其他事务都是不可见的，通常这使用锁来实现，当前数据库系统都提供了一种粒度锁的策略，不同数据库通过使用的锁的粒度不同来实现不同等级的隔离级别。允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。

**D durability 持久性：** 事务一旦提交，其结果就是永久的，即使发生宕机等故障，数据库也能将事务恢复，需要注意的是，只能从事务本身的角度来保证结果的永久性，例如，在事务提交以后，所有的变化都是永久的。即使数据库因为崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失，但若不是数据库本身发生故障，而是一些外部原因，如自然灾害等，那么所有提交的数据可能都会丢失，因此持久性保证事务系统的高可靠性，而不是高可用性。对于高可用性的实现，事务本身并不能保证，需要一些系统共同配合来实现。

### 事务的分类

从事务理论的角度来说，可以把事务分为以下几种类型：

* 扁平事务
* 带有保存点的扁平事务
* 链事务
* 嵌套事务
* 分布式事务

### 扁平事务

扁平事务是事务类型中最简单的一种，也是使用最多的一种，在扁平事务中，所有操作处于同一层级，其由begin开启，由commit或rollback结束。其间的操作的原子的，要么都执行，要么都回滚。因此扁平事务是应用程序成为原子操作的基本组成模块。

~~~sql
扁平事务的三种情况：
1. begin;
   op1;
   op2;
   op3;
   commit;
2. begin;
   op1;
   op2;
   op3;失败，异常
   rollback；
   应用程序要求停止事务。
3. begin；
   op1；
   op2；
   由于外界原因要回滚，如死锁等。
~~~

扁平事务的主要限制是不能提交或回滚事务的某一部分，或分几个步骤进行提交。也就是说，如果支持有计划的回滚操作，那么不需要终止整个事务，因此就出现了带有保存点的扁平事务。

### 带有保存点的扁平事务

除了支持扁平事务支持的操作外，带有保存点的扁平事务还支持在事务执行的过程中回滚到同一个事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不太合算。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误后可以回到保存点。

### 链事务

链事务可视为保存点模式的一种变种，带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为保存点是易失的，而不是持久的，这意味进行恢复时，事务需要从最开始处重新执行。而不能从最近的一个保存点开始执行。

链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传个下一个要开始的事务。提交事务的操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将能看到上一个事务的结果。就好像在一个事务中发生的一样。

链事务与带有保存点的扁平事务的不同的是，带有保存点的扁平事务能回滚到任意正确的保存点，而链事务的回滚只存在于当前事务。

### 嵌套事务

嵌套事务是一个层次结构，由一个顶层事务控制着各个层次的子事务，最终形成一个类似树状的一种结构。

嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。

处在叶子节点的事务一定是扁平事务，但是每个子事务从根到叶节点的距离可以是不同的。

子事务的提交不能马上生效，除非其父事务已经提交。所以可以得出一个结论，任何子事务都是在顶层事务提交以后才真正提交。

树中的任意一个事务的回滚的都会引起它的所有子事务的回滚。故子事务仅保留ACI特性，不具有D特性。

### 分布式事务

通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。在mall电商项目文档中，会详细总结分布式事务的问题。

对于InnoDB存储引擎来说，其支持扁平事务，带有保存点的扁平事务，链事务，分布式事务，对于嵌套事务是原生不支持的。对于有并行事务需求的用户来说，InnoDB存储引擎就显得无能为力了。

### 事务的实现

事务隔离性是由锁来实现的，原子性，一致性，持久性由redo log和undo log来完成。redo log称为重做日志，用来保证事务的原子性和持久性。undo log来保证事务的一致性。

redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。两者记录的内容是完全不同的，redo通常是物理日志，记录的是页的物理修改操作，undo是逻辑日志，根据每行记录进行记录。

### redo

重做日志用来实现事务的持久性，redo由两部分组成，一部分是内存中的重做日志缓冲，其是易失的，另一部分是重做日志文件，是持久的。

InnoDB存储引擎是事务存储引擎，其通过force log at commit机制实现事务的持久性，即当事务提交时，必须先将该事务所有的日志写入到重做日志文件中进行持久化，然后事务才能进行提交，最终一个事务才算完成。这里的日志指的是重做日志，redo log是来保证事务的持久性，undo是来帮助事务进行回滚及MVCC功能。redo log基本上都是顺序写的，在数据库运行时不需要对redo log进行读取操作。而undo log是要进行随机读写的。

在Mysql中还有一种二进制日志（binlog），其用来进行point-in-time的恢复及主从复制环境的搭建。

binlog和redolog是有很大不同的，首先，重做日志是在InnoDB存储引擎层产生的，而二进制日志时在mysql数据库上层的一种逻辑日志，其记录的是对应的sql语句，而InnoDB存储引擎层面的重做日志是物理格式日志，其记录的是对每个页的修改。

此外，两种日志的刷盘的时间点不同，二进制日志只在事务提交完成后进行一次写入，而redo在事务进行中不断地进行写入，并在事务提交之前完成落盘，以此才能保证事务的持久性。

### log block

在InnoDB存储引擎中，重做日志都是以512字节进行存储的，这意味着重做日志缓冲，重做日志文件都是以块的方式进行保存的，称之为重做日志块。每块的大小为512字节。

若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储，此外，由于重做日志块的大小和磁盘扇区大小一样，都是512字节，所以日志的写入是可以保证原子性的，不需要doublewrite技术。重做日志除了日志本身记录的内容以外，还有日志头和日志块尾两部分组成，头占12字节，尾占8字节，故每个重做日志块存储的实际内容为492字节。

重做日志文件中存储的就是之前在重做日志缓冲中记录的log buffer中的log block，因此其也是根据块的方式进行物理存储管理的。

在InnoDB存储引擎运作过程中，log buffer根据一定规则将内存中的log block刷新到磁盘中

* 事务提交时
* 当log buffer中有一半的内存空间已经被使用时
* log checkpoint时

由于checkpoint表示已经刷新到了磁盘页上的LSN处，因此在恢复过程中仅需恢复checkpoint开始的日志部分。

### redo

重做日志记录了事务的行为，可以很好地通过其对页进行重做操作，但是事务有时还需要回滚操作，这就需要undo。因此在对数据库进行修改时，不仅会产生redo，还有产生undo。

redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段中，这个段称为undo段，undo段是位于共享表空间中的。

开发者不可以对undo有这样的误解：

undo用于将数据库恢复到物理地恢复到执行语句或事务之前的样子，这是错误的。undo是逻辑日志，也就说只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚后可能大不相同了。这是因为在多用户并发系统中，可能会有数十，数百个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有另一个事务在对同一页中的另外几条记录进行修改，因此不能将一个页物理回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。

~~~wiki
举个例子：
一个用户执行了一个insert 10w条数据的事务，这个事务会导致分配一个新的段，即表空间会增大，在用户执行rollback之后
会将插入的事务进行回滚，但是表空间不会收缩，因此当进行回滚时，它实际上做的是与之前相反的工作，对于每个insert，它会来一个delete，来一个update，InnoDB存储引擎会来一个与之相反的update。
~~~

除了回滚操作，undo的另一个作用就是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成的，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo来读取之前的行版本信息，以此来实现非锁定读。

最后也是最为重要的一点，undo也会产生redo，也就是undo的产生会伴随着redo的产生，因为undo同样需要redo提供的持久化。

undo log有两种，一种是insert undo，一种是update undo。

insert undo是指在insert操作中产生的undo，因为insert操作的记录，只对事务本身可见，对其他事务不可见，这是事务隔离性的要求，所以这种undo log可以在事务提交以后直接删除，（提交以后就不能回滚了，留着没什么用），不需要进行purge操作。

update undo是指update和delete操作产生的undo，该undo可能需要提供MVCC机制，因此不能在事务提交以后就删除，提交时放入undo链表，等待purge线程进行最后的删除。

### purge

delete和update操作可能并不直接删除原有的数据，只是将这条记录的delete flag设置为1，记录并没有被删除，即记录还在B+树中，而真正的删除操作延时在了purge操作中

purge用来最终完成delete和update操作，这样设计是因为InnoDB存储引擎支持MVCC机制，所以记录不能在事务提交时立即进行处理，这时其他事务可能正在引用该行，故InnoDB存储引擎需要保存记录之前的版本，而是否可以删除这条记录需要由purge进行判断，若该行记录不再由任何其他事务引用，那么就可以真正进行delete操作，可见，purge是用来清理之前的delete和update操作，将这些操作最终完成。

### group commit

若事务为非只读事务，则每次在事务提交时需要进行一次fsync操作，以此保证重做日志都已经写入磁盘，当数据库发生宕机时，可以通过重做日志进行恢复。虽然固态硬盘的出现提高了磁盘的性能，然而磁盘的fsync性能还是有限的，为了提高效率，当前数据库都采用group commit的功能，即一次fsync可以刷新确保多个事务日志被写入文件。对于InnoDB存储引擎来说，事务提交会进行两个阶段的操作

* 修改内存中事务对应的信息，并且将日志写入重做日志缓冲
* 调用fsync确保日志都从重做日志缓冲写入到磁盘中

### 隐式提交的SQL语句

有一些SQL语句是隐式提交的，即执行完这些SQL语句后，会有一个隐式的commit操作。

特别注意的是TRUNCATE TABLE语句是DDL语句，是一个隐式提交的SQL语句，所有DDL语句都是隐式提交语句。

TRUNCATE TABLE和DROP TABLE都是DDL，所以虽然和对整张表执行delete的结果是一样的，但它是不能回滚的。

### 事务的隔离级别

ISO国际标准化组织规定了事务的四种隔离级别，但是有些数据库并没有遵守这些规定，比如oracle就不支持RU和RR隔离级别

InnoDB存储引擎默认支持的隔离级别是RR，但是与SQL标准不同的是，InnoDB存储引擎在RR隔离级别下，使用next key lock锁的算法，避免了幻读的产生，所以说InnoDB存储引擎在默认的RR下已经能完全保证事务的隔离性要求，即达到了SQL标准的SER隔离级别。

隔离级别越低，事务的锁越少或者保持锁的时间越短，这也是为什么大多数数据库使用RC隔离级别，但是经过验证SER隔离级别和RC隔离级别的性能相差不大，没有影响。（Jim Gray）

在SER隔离级别，InnoDB存储引擎会对每个select语句后面自动加上lock in share mode，也就是为每个读取操作加上共享锁，因此在这个隔离级别下，读占用了锁，对一致性的非锁定读不再支持。SER一般使用在InnoDB存储引擎的分布式事务中。

在RC下，除了唯一性的约束检查及外键约束的检查需要gap lock，InnoDB存储引擎不会使用gap lock的算法。

建议！！将二进制日志的格式更换成ROW格式，因为这个格式记录的是行的变更，而不是简单的SQL语句，所以可以避免不同步现象的产生，进一步保证数据的同步。

###  分布式事务

InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中，事务资源通常是关系型数据库系统，全局事务要求在其中参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高，另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SER级别

XA事务由一个或多个资源管理器（Resource manager），一个事务管理器（Transaction manager）以及一个应用程序（AP）或者叫TC，事务调度器组成，





