# 《MySQL技术内幕：InnoDB存储引擎》

## 前言

MySQL独有的插件式存储引擎架构使其和其他任何数据库都不同。不同的存储引擎有着完全不同的功能，而InnoDB存储引擎的存在使得MySQL跃入了企业级数据库领域。

## 第一章 MySQL体系结构和存储引擎

MySQL由以下几个部分组成：

* 连接池组件 Connectors：JDBC ODBC NET PHP Python等
* 管理服务和工具组件 management service&utils
* SQL接口组件
* 查询分析器组件
* 优化器组件
* 缓冲组件
* 插件式存储引擎
* 物理文件

1.InnoDB存储引擎

InnoDB存储引擎支持事务，设计目标主要面向在线事务处理（OLTP）的应用，特点是支持行锁设计，支持外键，支持事务，并且支持类似于Oracle的非锁定读，即默认读取不会产生锁

InnoDB通过多版本并发控制（MVVC）来获得高并发性，并且实现了SQL标准的四种隔离级别，默认为可重复度（repeatable read）。

同时使用一种被称为next-key locking 的策略来避免幻读现象的产生。

初次以外，InnoDB还提供了 插入缓冲（insert buffer），二次写（double write），自适应哈希索引（adaptive hash index），预读等高性能和高可用的功能。

对于表中的数据，InnoDB存储引擎采用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。如果没有显示的在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。

2.MyISAM存储引擎

MyISAM存储引擎不支持事务，不支持行锁，只支持表锁，支持全文索引。主要面向一些OLAP的应用，在MySQL5.5.8之前MyISAM存储引擎是默认的存储引擎。另外，MyISAM存储引擎另一个与众不同的地方是它的缓冲池只缓存索引文件，而不缓冲数据文件。

MyISAM存储引擎表由MYD和MYI组成，前者存放数据文件，后者存放索引文件。

3.Memory存储引擎

Memory存储引擎将表中的数据存放在内存中，如果数据库重启或者发生崩溃，表中的数据都将丢失。适用于存储临时数据的临时表。默认使用哈希索引，而不是B+树索引。

Memory存储引擎速度上非常快，但在使用上有一些限制，比如，只支持表锁，并发性能较差，并且不支持TEXT,BLOB列类型，并且在存储变长字段（varchar）时是按照定长字段（char）的方式进行的，会产生内存的浪费。

## 第二章 InnoDB存储引擎

从MySQL5.5开始InnoDB是默认的存储引擎。该存储引擎是第一个完整支持ACID事务的MySQL存储引擎。特点是行锁设计，支持MVCC，支持外键，提供一致性非锁定读。

### 1.InnoDB体系架构

InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：

* 维护所有进程/线程需要访问的多个内部数据结构
* 缓存磁盘上的数据，方便快速读取，同时在对磁盘文件的数据修改之前在这里缓存
* 重做日志缓冲

内存池里面有很多的后台线程，后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最新的数据。

此外将已经修改的数据文件刷新到磁盘文件。同时还要保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。

后台线程：

InnoDB存储引擎是多线程模型，因此后台有多个不同的后台线程，负责处理不同的任务。

1.Master thread

master thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲，undo页的回收等。

2.IO thread

在InnoDB存储引擎中大量使用AIO来处理写IO请求，这样可以极大提升数据库的性能，IO thread就是用来处理这些io请求的回调任务。

3.Purge thread

事务被提交以后，其所使用的undolog可能不再被需要，因此需要Purge thread来回收已经使用并分配的undo页，在inndoDB存储引擎1.1版本之前，purge的操作在master thread中完成，从inndDB1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻master thread的工作，从而提高CPU的利用率以及提升存储引擎的性能。

4.Page cleaner thread

Page cleaner thread是在innoDB1.2.x版本引进的，作用是将之前版本中脏页的刷新操作都放入到单独的线程中来进行，目的是减轻master thread的工作及对于用户查询线程的阻塞，进一步提升innoDB存储引擎的性能。

### 缓冲池

InnoDB存储引擎是基于磁盘进行存储的，并将其中的记录按照页的方式来进行管理，因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于CPU与内存之间存在巨大的速度鸿沟，基于磁盘的数据库系统经常使用缓冲池技术来提高数据库的整体性能。

缓冲池简单来说就是内存中的一块区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响，在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中，下一次再读取相同的时，首先判断该页是否在缓冲池中，如果命中，则直接在缓冲池中读取。

对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上，对于页刷新回磁盘这个操作，并不是发生在每次页更新时，而是通过一种称为checkpoint的机制刷新回磁盘中，同样，这样做也是为了提升数据库的整体性能。

![image](https://note.youdao.com/yws/api/personal/file/WEB3b9d1a5a821d97f9137b7e18101f0630?method=download&shareKey=c598caedba0ee0a3103926a4267d3b90)

具体的，缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InnoDB存储的锁信息，数据字典信息等。不能简单认为缓冲池只缓存数据页和索引页，它们只是占据缓冲池很大的一部分而已。

在InnoDB1.0.x版本开始，允许有多个缓冲池实例，每个页根据哈希值平均分配的不同的缓冲池实例中，这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。

缓冲池是一个很大的内存区域，里面存放着各种类型的页，InnoDB存储引擎通过LRU List 算法来进行管理，即最频繁使用的页来LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，就要通过LRU（最近最少使用）来释放LRU列表中尾端的页。

在InnoDB存储引擎中，缓冲池中页默认大小为16kb，它的LRU算法相对来说也要一定的改进，在InnoDB存储引擎中，LRU列表中还加入了midpoint位置，新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置，在默认配置下，这个位置在LRU列表长度的八分之五处，在参数中value=37，代表距离列表尾端八分之三的位置处，在InnoDB存储引擎中，把midpoint之后的列表称为old列表，之前的列表称为new列表，可以理解为new列表中的页都是最为活跃的热点数据。

如果采用朴素的LRU算法，直接将读取到的最新的页放入到LRU列表的首部中，那么某些SQL操作可能会使缓冲池中的页被刷出，从而影响缓冲池的效率。

常见的这种操作比如：索引或数据的扫描操作，这类操作需要访问表中的许多页，甚至是全部的页，但这些页通常来说仅仅在这一次查询中起到作用，并不是活跃的热点数据，如果将这些页放入到LRU列表的首部，那么可能会导致真正的热点数据页从LRU列表中移除。

LRU列表用来管理已经读取到的页，当数据库刚启动的时候，LRU列表是空的，即没有任何的页。这时候页都存放在Free列表中。

在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页产生了不一致。这时候数据库会通过checkpoint机制将脏页刷新回磁盘，而FLUSH列表中的页即为脏页列表。需要注意的是：脏页既存在于LRU列表中，也存在于Flush列表中，LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。

### 重做日志缓冲

InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲和额外的内存池。InnoDB存储引擎首先将重做日志信息放入到这个缓冲区，然后按照一定频率将其刷新到重做日志文件中。

下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中：

* master thread每一秒将重做日志缓冲刷新到重做日志文件
* 每个事务提交时会将重做日志缓冲刷新到重做日志文件中
* 当重做日志缓冲池剩余空间小于二分之一时，重做日志缓冲刷新到重做日志文件

### 额外的内存池

Innodb_buffer_pool中的帧缓冲(frame buffer) 以及对应的 缓冲控制对象（buffer controll block，这些对象记录了一些诸如LRU、锁、等待等信息）这些数据对象本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域内存不够时，会从缓冲池中申请。所以，如果我们设置了很大的InnoDB缓冲池时，也应考虑相应的增加额外内存池的大小。

###  checkpoint技术

缓冲池设计的目的视为了协调CPU速度与磁盘速度的鸿沟，因此页的操作首先都是在缓冲池（内存）中完成的。如果一条DML语句，比如update，delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池刷新到磁盘中。倘若每次页发生了变化，就将页的版本刷新到磁盘，那么开销是非常大的。而且如果在刷新回磁盘的过程中发生了宕机，那么数据就不能恢复了，为了避免数据的丢失问题，事务数据库系统普遍采用write ahead log策略，就是当事务提交时，先写重做日志，再修改页。当由于宕机而导致数据丢失时，可以通过重做日志来完成数据的恢复工作。

这就是事务ACID中D（Durability持久性）的要求。

checkpoint技术出现的场景:

如果重做日志做的无限的大，同时缓冲池也是无限的大，那么不需要将缓冲池中的页刷新回到磁盘中，因为当发生宕机的时候，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生的时刻。

两个前提条件：

* 缓冲池可以缓存数据库中所有的数据
* 重做日志需要做的无限大（可以记录这个数据库系统中所有的修改操作，可以全部回滚）

对于第一个前提，缓冲池就是内存，而对于数据库服务器，随着业务不断的增长，内存会变得越来越大，不现实

对于第二个前提，即使可以使用超大磁盘来存储超大重做日志文件，但是假如数据库运行了好几年，这时候宕机了，需要进行数据恢复，所需要的耗费的时间将是难以想象的。

**checkpoint技术解决的问题：**

1.**缩短数据库的恢复时间**

2.**缓冲池不够用时，将脏页刷新到磁盘**

3.**重做日志不可用时，刷新脏页（这句话我的理解是重做日志不可用指的是重做日志大小满了，需要循环复用，那么会覆盖一部分以前的重做日志，这时候要进行强制checkpoint，将脏页刷新回磁盘）**

对于第一个解决的问题，缩短数据库的恢复时间，因为数据库不需要重做所有的日志，在checkpoint之前的页都已经刷新回磁盘了，故数据库只需对checkpoint之后的重做日志进行恢复，这样大大缩短了重做需要耗费的时间。

缓冲池不够用的时候，还会使用LRU算法溢出最近最少使用的页，若此页为脏页，那么需要强制执行checkpoint，将脏页，也就是新版本的页刷新到磁盘中。

重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本和管理上来说都是比较困难的。重做日志可以被重用的部分是指当前部分不再被需要，即当数据库发生宕机时，数据的恢复我也不需要你这段重做日志，因此这部分可以被覆盖使用。若此时重做日志还需要被使用，那么强制进行checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。

### 两种checkpoint技术

对于InnoDB存储引擎而言，其是通过LSN来标记版本的，而LSN是8字节的数字，单位是字节，每个页有LSN，重做日志中有LSN，checkpoint也有LSN。

在InnoDB存储引擎中，checkpoint发生的时间，条件和脏页的选择等都非常的复杂。而checkpoint所做的事情无外乎是将缓冲池中的脏页（新版本的页）刷回磁盘。

在InnoDB存储引擎中，有两种checkpoint，分别为：

1.sharp checkpoint

2.fuzzy checkpoint

sharp checkpoint发生在数据库关闭时将所有的脏页刷新回到磁盘中，这是默认的工作方式

但是若在数据库运行的时候也是用sharp checkpoint，那么对数据库的可用性会受到巨大的影响，我个人认为这里的影响比较类似于JVM中垃圾回收导致的STW（stop the world），为了解决这个问题，在innoDB存储引擎内部，使用fuzzy checkpoint进行页的刷新，即只刷新部分脏页，而不是刷新所以的脏页。

在inndoDB存储引擎中存在一下几种情况的fuzzy checkpoint

1.master thread checkpoint

每秒或者每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘，这个过程是异步进行的，用户查询不会受到阻塞。

2.flush_lru_list checkpoint 

innoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。

3.async/sync flush checkpoint 指的是重做日志文件不可用的情况，这时候需要强制将一些页刷新回磁盘。

本文总结自《MySQL技术内幕：InnoDB存储引擎》p1 -- p36



