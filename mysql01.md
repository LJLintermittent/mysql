# 《MySQL技术内幕：InnoDB存储引擎》

## 前言

MySQL独有的插件式存储引擎架构使其和其他任何数据库都不同。不同的存储引擎有着完全不同的功能，而InnoDB存储引擎的存在使得MySQL跃入了企业级数据库领域。

## 第一章 MySQL体系结构和存储引擎

MySQL由以下几个部分组成：

* 连接池组件 Connectors：JDBC ODBC NET PHP Python等
* 管理服务和工具组件 management service&utils
* SQL接口组件
* 查询分析器组件
* 优化器组件
* 缓冲组件
* 插件式存储引擎
* 物理文件

1.InnoDB存储引擎

InnoDB存储引擎支持事务，设计目标主要面向在线事务处理（OLTP）的应用，特点是支持行锁设计，支持外键，支持事务，并且支持类似于Oracle的非锁定读，即默认读取不会产生锁

InnoDB通过多版本并发控制（MVVC）来获得高并发性，并且实现了SQL标准的四种隔离级别，默认为可重复度（repeatable read）。

同时使用一种被称为next-key locking 的策略来避免幻读现象的产生。

初次以外，InnoDB还提供了 插入缓冲（insert buffer），二次写（double write），自适应哈希索引（adaptive hash index），预读等高性能和高可用的功能。

对于表中的数据，InnoDB存储引擎采用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。如果没有显示的在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。

2.MyISAM存储引擎

MyISAM存储引擎不支持事务，不支持行锁，只支持表锁，支持全文索引。主要面向一些OLAP的应用，在MySQL5.5.8之前MyISAM存储引擎是默认的存储引擎。另外，MyISAM存储引擎另一个与众不同的地方是它的缓冲池只缓存索引文件，而不缓冲数据文件。

MyISAM存储引擎表由MYD和MYI组成，前者存放数据文件，后者存放索引文件。

3.Memory存储引擎

Memory存储引擎将表中的数据存放在内存中，如果数据库重启或者发生崩溃，表中的数据都将丢失。适用于存储临时数据的临时表。默认使用哈希索引，而不是B+树索引。

Memory存储引擎速度上非常快，但在使用上有一些限制，比如，只支持表锁，并发性能较差，并且不支持TEXT,BLOB列类型，并且在存储变长字段（varchar）时是按照定长字段（char）的方式进行的，会产生内存的浪费。

## 第二章 InnoDB存储引擎

从MySQL5.5开始InnoDB是默认的存储引擎。该存储引擎是第一个完整支持ACID事务的MySQL存储引擎。特点是行锁设计，支持MVCC，支持外键，提供一致性非锁定读。

### 1.InnoDB体系架构

InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：

* 维护所有进程/线程需要访问的多个内部数据结构
* 缓存磁盘上的数据，方便快速读取，同时在对磁盘文件的数据修改之前在这里缓存
* 重做日志缓冲

内存池里面有很多的后台线程，后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最新的数据。

此外将已经修改的数据文件刷新到磁盘文件。同时还要保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。

后台线程：

InnoDB存储引擎是多线程模型，因此后台有多个不同的后台线程，负责处理不同的任务。

1.Master thread

master thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲，undo页的回收等。

2.IO thread

在InnoDB存储引擎中大量使用AIO来处理写IO请求，这样可以极大提升数据库的性能，IO thread就是用来处理这些io请求的回调任务。

3.Purge thread

事务被提交以后，其所使用的undolog可能不再被需要，因此需要Purge thread来回收已经使用并分配的undo页，在inndoDB存储引擎1.1版本之前，purge的操作在master thread中完成，从inndDB1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻master thread的工作，从而提高CPU的利用率以及提升存储引擎的性能。

4.Page cleaner thread

Page cleaner thread是在innoDB1.2.x版本引进的，作用是将之前版本中脏页的刷新操作都放入到单独的线程中来进行，目的是减轻master thread的工作及对于用户查询线程的阻塞，进一步提升innoDB存储引擎的性能。

### 缓冲池

InnoDB存储引擎是基于磁盘进行存储的，并将其中的记录按照页的方式来进行管理，因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于CPU与内存之间存在巨大的速度鸿沟，基于磁盘的数据库系统经常使用缓冲池技术来提高数据库的整体性能。

缓冲池简单来说就是内存中的一块区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响，在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中，下一次再读取相同的时，首先判断该页是否在缓冲池中，如果命中，则直接在缓冲池中读取。

对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上，对于页刷新回磁盘这个操作，并不是发生在每次页更新时，而是通过一种称为checkpoint的机制刷新回磁盘中，同样，这样做也是为了提升数据库的整体性能。

![image](https://note.youdao.com/yws/api/personal/file/WEB3b9d1a5a821d97f9137b7e18101f0630?method=download&shareKey=c598caedba0ee0a3103926a4267d3b90)

具体的，缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InnoDB存储的锁信息，数据字典信息等。不能简单认为缓冲池只缓存数据页和索引页，它们只是占据缓冲池很大的一部分而已。

在InnoDB1.0.x版本开始，允许有多个缓冲池实例，每个页根据哈希值平均分配的不同的缓冲池实例中，这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。

缓冲池是一个很大的内存区域，里面存放着各种类型的页，InnoDB存储引擎通过LRU List 算法来进行管理，即最频繁使用的页来LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，就要通过LRU（最近最少使用）来释放LRU列表中尾端的页。

在InnoDB存储引擎中，缓冲池中页默认大小为16kb，它的LRU算法相对来说也要一定的改进，在InnoDB存储引擎中，LRU列表中还加入了midpoint位置，新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置，在默认配置下，这个位置在LRU列表长度的八分之五处，在参数中value=37，代表距离列表尾端八分之三的位置处，在InnoDB存储引擎中，把midpoint之后的列表称为old列表，之前的列表称为new列表，可以理解为new列表中的页都是最为活跃的热点数据。

如果采用朴素的LRU算法，直接将读取到的最新的页放入到LRU列表的首部中，那么某些SQL操作可能会使缓冲池中的页被刷出，从而影响缓冲池的效率。

常见的这种操作比如：索引或数据的扫描操作，这类操作需要访问表中的许多页，甚至是全部的页，但这些页通常来说仅仅在这一次查询中起到作用，并不是活跃的热点数据，如果将这些页放入到LRU列表的首部，那么可能会导致真正的热点数据页从LRU列表中移除。

